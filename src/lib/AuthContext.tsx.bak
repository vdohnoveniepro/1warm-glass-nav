'use client';

import React, { createContext, useContext, useState, useEffect, useCallback, useMemo, ReactNode } from 'react';
import { getCookie } from '../lib/utils';
import { User, UserRole } from '../models/types';
import { create } from 'zustand';
import { useRouter } from 'next/navigation';
import toast from 'react-hot-toast';
import { getUserRoleDisplayName, isAdmin, isSpecialist } from '@/utils/user-roles';

interface AuthContextType {
  user: User | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  authToken: string | null;
  login: (email: string, password: string) => Promise<boolean>;
  register: (userData: { firstName: string; lastName: string; email: string; password: string; phone?: string; }) => Promise<boolean>;
  logout: () => Promise<void>;
  refreshUser: () => Promise<boolean>;
  getAuthToken: () => string | null;
  updateUserInfo: (userData: Partial<User>) => void;
  showLoginModal: (returnUrl?: string, onSuccess?: () => void) => void;
  loginWithTelegram: (telegramData: any) => Promise<boolean>;
}

// Создаем стор для управления состоянием модального окна авторизации
export const useAuthModalStore = create<{
  isOpen: boolean;
  returnUrl: string | null;
  onSuccess?: () => void;
  open: (returnUrl?: string | null, onSuccess?: () => void) => void;
  close: () => void;
}>((set) => ({
  isOpen: false,
  returnUrl: null,
  onSuccess: undefined,
  open: (returnUrl = null, onSuccess) => set({ isOpen: true, returnUrl, onSuccess }),
  close: () => set({ isOpen: false, returnUrl: null, onSuccess: undefined }),
}));

const AuthContext = createContext<AuthContextType>({
  user: null,
  isLoading: true,
  isAuthenticated: false,
  authToken: null,
  login: async () => false,
  register: async () => false,
  logout: async () => {},
  refreshUser: async () => false,
  getAuthToken: () => null,
  updateUserInfo: () => {},
  showLoginModal: () => {},
  loginWithTelegram: async () => false,
});

export const useAuth = () => useContext(AuthContext);

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [authToken, setAuthToken] = useState<string | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const router = useRouter();

  // Функция для загрузки данных пользователя
  const fetchUserData = useCallback(async (): Promise<{ user: User | null, token: string | null }> => {
    try {
      console.log("[AuthContext] Запрашиваем данные пользователя с сервера");
      const response = await fetch('/api/auth/me', {
        credentials: 'include' // Важно для работы с куками
      });
      
      if (response.ok) {
        const userData = await response.json();
        console.log("[AuthContext] Получен ответ от /api/auth/me:", { success: userData.success });
        
        if (userData.success) {
          const token = userData.data.token || null;
          
          // Сохраняем токен в localStorage для сохранения между обновлениями страницы
          if (token) {
            console.log("[AuthContext] Сохраняем полученный токен в localStorage");
            localStorage.setItem('auth_token', token);
          }
          
          return { user: userData.data.user, token };
        }
      }
      
      // Если не удалось получить данные с сервера, пробуем использовать кеш
      const cachedUser = localStorage.getItem('user_data');
      if (cachedUser) {
        try {
          console.log("[AuthContext] Используем кешированные данные пользователя");
          const parsedUser = JSON.parse(cachedUser);
          return { user: parsedUser, token: authToken || localStorage.getItem('auth_token') };
        } catch (e) {
          console.error("[AuthContext] Ошибка при разборе кешированных данных:", e);
        }
      }
      
      // При неудаче очищаем localStorage
      console.log("[AuthContext] Не удалось получить данные пользователя, очищаем кеш");
      // localStorage.removeItem('auth_token');  // Не удаляем токен при ошибке, может пригодиться
      return { user: null, token: null };
    } catch (error) {
      console.error('[AuthContext] Error fetching user data:', error);
      return { user: null, token: null };
    }
  }, [authToken]);

  // Мемоизируем getAuthToken
  const getAuthToken = useCallback((): string | null => {
    // Проверяем localStorage
    if (typeof window !== 'undefined') {
      const token = localStorage.getItem('auth_token');
      if (token) return token;
      
      // Проверяем cookie через функцию getCookie
      const cookieToken = getCookie('auth_token');
      if (cookieToken) return cookieToken;
    }
    
    return null;
  }, []);

  // Проверка авторизации при загрузке
  useEffect(() => {
    const checkAuth = async () => {
      try {
        console.log("[AuthContext] Проверка авторизации при загрузке страницы");
        
        // Проверяем наличие сессионного токена
        const sessionToken = getCookie('next-auth.session-token') || 
                           getCookie('__Secure-next-auth.session-token');
        const storedToken = localStorage.getItem('auth_token');
        const clientAuthToken = getCookie('client_auth_token');
        const authCookie = getCookie('auth_token');

        console.log("[AuthContext] Проверка токенов:", { 
          hasSessionToken: !!sessionToken, 
          hasStoredToken: !!storedToken,
          hasClientAuthToken: !!clientAuthToken,
          hasAuthCookie: !!authCookie
        });

        // Если найден токен, сразу устанавливаем isAuthenticated в true и восстанавливаем пользователя из localStorage
        if (storedToken || clientAuthToken || authCookie) {
          console.log("[AuthContext] Найден токен в localStorage или куки, устанавливаем флаг авторизации");
          setAuthToken(storedToken || clientAuthToken || authCookie);
          
          // Пробуем восстановить пользователя из localStorage
          const cachedUser = localStorage.getItem('user_data');
          if (cachedUser) {
            try {
              console.log("[AuthContext] Используем кешированные данные пользователя");
              const parsedUser = JSON.parse(cachedUser);
              setUser(parsedUser);
              setIsAuthenticated(true);
              console.log("[AuthContext] Пользователь восстановлен из localStorage:", parsedUser.email);
            } catch (e) {
              console.error("[AuthContext] Ошибка при разборе кешированных данных:", e);
            }
          }
        }

        if (!sessionToken && !storedToken && !clientAuthToken && !authCookie) {
          console.log("[AuthContext] Токены не найдены, пользователь не авторизован");
          setUser(null);
          setIsLoading(false);
          setIsAuthenticated(false);
          return;
        }

        // Загружаем данные пользователя с сервера
        const { user: fetchedUser, token } = await fetchUserData();
        
        if (fetchedUser) {
          console.log("[AuthContext] Пользователь получен успешно:", fetchedUser.email);
          
          // Специальная обработка для пользователя bakeevd@yandex.ru
          if (fetchedUser.email === 'bakeevd@yandex.ru') {
            console.log("[AuthContext] Обнаружен специальный пользователь bakeevd@yandex.ru, устанавливаем роль ADMIN");
            fetchedUser.role = UserRole.ADMIN;
          }
          
          setUser(fetchedUser);
          setIsAuthenticated(true);
          
          // Кешируем данные пользователя
          localStorage.setItem('user_data', JSON.stringify(fetchedUser));
          
          if (token) {
            setAuthToken(token);
            localStorage.setItem('auth_token', token);
          }
        } else {
          // Если не удалось получить пользователя, но есть кеш - используем его
          const cachedUser = localStorage.getItem('user_data');
          
          if (cachedUser) {
            try {
              console.log("[AuthContext] Не удалось получить пользователя с сервера, используем кеш");
              const parsedUser = JSON.parse(cachedUser);
              setUser(parsedUser);
              setIsAuthenticated(true);
            } catch (e) {
              console.error("[AuthContext] Ошибка при разборе кешированных данных:", e);
              setUser(null);
              setIsAuthenticated(false);
            }
          } else {
            console.log("[AuthContext] Пользователь не найден ни на сервере, ни в кеше");
            setUser(null);
            setIsAuthenticated(false);
          }
        }
      } catch (error) {
        console.error('[AuthContext] Error checking auth:', error);
        setUser(null);
        setIsAuthenticated(false);
      } finally {
        setIsLoading(false);
      }
    };

    checkAuth();
  }, [fetchUserData]);

  // Функция для входа
  const login = async (email: string, password: string): Promise<boolean> => {
    try {
      console.log('[AuthContext] Начало процесса входа:', { email });
      
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ email, password }),
        credentials: 'include', // Важно для сохранения куки
      });
      
      console.log('[AuthContext] Ответ сервера:', { 
        status: response.status, 
        statusText: response.statusText 
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        console.error('[AuthContext] Ошибка входа:', errorData);
        return false;
      }
      
      const data = await response.json();
      console.log('[AuthContext] Успешный вход, данные:', { 
        success: data.success, 
        hasToken: !!data.data?.token, 
        hasUser: !!data.data?.user 
      });
      
      if (data.success && data.data) {
        // Сохраняем пользователя в состоянии
        setUser(data.data.user);
        setIsAuthenticated(true);
        
        // Сохраняем данные пользователя в localStorage
        localStorage.setItem('user_data', JSON.stringify(data.data.user));
        
        // Сохраняем токен в localStorage и устанавливаем его в состоянии
        if (data.data.token) {
          setAuthToken(data.data.token);
          localStorage.setItem('auth_token', data.data.token);
          console.log('[AuthContext] Токен сохранен в localStorage, длина:', data.data.token.length);
        }
        
        console.log('[AuthContext] Состояние после входа:', { 
          isAuthenticated: true, 
          userId: data.data.user?.id 
        });
        
        // Обновляем заголовок авторизации для всех последующих запросов
        if (data.data.token) {
          const authHeader = `Bearer ${data.data.token}`;
          console.log('[AuthContext] Устанавливаем заголовок авторизации для будущих запросов');
        }
        
        // Показываем уведомление об успешном входе
        toast.success('Вы успешно вошли в систему');

        // Перенаправляем пользователя в кабинет
        router.push('/cabinet');
        
        return true;
      }
      
      console.error('[AuthContext] Ошибка входа: неверный формат ответа от сервера');
      return false;
    } catch (error) {
      console.error('[AuthContext] Исключение при входе:', error);
      toast.error(error.message || 'Ошибка при входе');
      return false;
    }
  };

  // Функция для регистрации
  const register = async (userData: { firstName: string; lastName: string; email: string; password: string; phone?: string; }): Promise<boolean> => {
    try {
      console.log("[AuthContext] Начало процесса регистрации");
      setIsLoading(true);
      
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(userData),
        credentials: 'include' // Важно для работы с куками
      });

      const data = await response.json();
      console.log("[AuthContext] Ответ от сервера register:", { success: data.success });
      
      if (response.ok && data.success && data.data) {
        console.log("[AuthContext] Регистрация успешна, сохраняем данные пользователя");
        
        // Сохраняем пользователя
        setUser(data.data.user);
        setIsAuthenticated(true);
        
        // Кешируем данные пользователя
        localStorage.setItem('user_data', JSON.stringify(data.data.user));
        
        // Сохраняем токен
        if (data.data.token) {
          setAuthToken(data.data.token);
          localStorage.setItem('auth_token', data.data.token);
          console.log("[AuthContext] Токен сохранен, длина:", data.data.token.length);
        } else {
          console.warn("[AuthContext] Токен отсутствует в ответе сервера");
        }
        
        // Показываем уведомление об успешной регистрации
        toast.success('Вы успешно зарегистрировались');

        // Перенаправляем пользователя в кабинет
        router.push('/cabinet');
        
        return true;
      }
      
      console.log("[AuthContext] Регистрация не удалась:", data.error);
      return false;
    } catch (error) {
      console.error('[AuthContext] Registration error:', error);
      toast.error(error.message || 'Ошибка при регистрации');
      return false;
    } finally {
      setIsLoading(false);
      console.log("[AuthContext] Процесс регистрации завершен");
    }
  };

  // Функция для выхода
  const logout = async (): Promise<void> => {
    try {
      console.log("[AuthContext] Начало процесса выхода");
      setIsLoading(true);
      
      await fetch('/api/auth/logout', { 
        method: 'POST',
        credentials: 'include'
      });
      
      setUser(null);
      setAuthToken(null);
      localStorage.removeItem('auth_token');
      localStorage.removeItem('user_data');
      
      console.log("[AuthContext] Выход выполнен успешно, данные очищены");

      // Показываем уведомление о выходе
      toast.success('Вы вышли из системы');

      // Перенаправляем пользователя на главную страницу
      router.push('/');
    } catch (error) {
      console.error('[AuthContext] Logout error:', error);
      toast.error('Ошибка при выходе из системы');
    } finally {
      setIsLoading(false);
    }
  };

  // Функция для обновления данных пользователя
  const refreshUser = async (): Promise<boolean> => {
    try {
      console.log('[AuthContext] Начало обновления данных пользователя');
      
      const response = await fetch('/api/auth/me', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include', // Важно для передачи куки
      });
      
      console.log('[AuthContext] Ответ на запрос данных пользователя:', { 
        status: response.status, 
        statusText: response.statusText 
      });
      
      if (!response.ok) {
        console.error('[AuthContext] Ошибка при получении данных пользователя:', response.statusText);
        return false;
      }
      
      const data = await response.json();
      console.log('[AuthContext] Получены данные пользователя:', { 
        hasUser: !!data.user, 
        userId: data.user?.id 
      });
      
      if (data.user) {
        // Специальная обработка для пользователя bakeevd@yandex.ru
        if (data.user.email === 'bakeevd@yandex.ru') {
          console.log('[AuthContext] Обнаружен специальный пользователь bakeevd@yandex.ru, устанавливаем роль ADMIN');
          data.user.role = UserRole.ADMIN;
        }
        
        setUser(data.user);
        setIsAuthenticated(true);
        console.log('[AuthContext] Пользователь обновлен в контексте');
        return true;
      } else {
        console.log('[AuthContext] Пользователь не найден в ответе');
        return false;
      }
    } catch (error) {
      console.error('[AuthContext] Исключение при обновлении пользователя:', error);
      return false;
    }
  };

  // Функция для обновления данных пользователя без запроса к серверу
  const updateUserInfo = (userData: Partial<User>): void => {
    setUser(prev => {
      if (!prev) return null;
      const updated = { ...prev, ...userData };
      
      // Кешируем обновленные данные
      localStorage.setItem('user_data', JSON.stringify(updated));
      
      return updated;
    });
  };

  // Функция для открытия модального окна авторизации
  const showLoginModal = useCallback((returnUrl?: string, onSuccess?: () => void) => {
    console.log('[AuthContext] Открываем модальное окно авторизации:', { returnUrl, hasCallback: !!onSuccess });
    useAuthModalStore.getState().open(returnUrl || null, onSuccess);
  }, []);

  // Функция для входа с помощью Telegram
  const loginWithTelegram = async (telegramData: any): Promise<boolean> => {
    try {
      console.log('[AuthContext] Начало процесса входа с помощью Telegram');
      
      const response = await fetch('/api/auth/telegram', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(telegramData),
        credentials: 'include', // Важно для сохранения куки
      });
      
      console.log('[AuthContext] Ответ сервера:', { 
        status: response.status, 
        statusText: response.statusText 
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        console.error('[AuthContext] Ошибка входа с помощью Telegram:', errorData);
        return false;
      }
      
      const data = await response.json();
      console.log('[AuthContext] Успешный вход с помощью Telegram:', { 
        success: data.success, 
        hasToken: !!data.data?.token, 
        hasUser: !!data.data?.user 
      });
      
      if (data.success && data.data) {
        // Сохраняем пользователя в состоянии
        setUser(data.data.user);
        setIsAuthenticated(true);
        
        // Сохраняем данные пользователя в localStorage
        localStorage.setItem('user_data', JSON.stringify(data.data.user));
        
        // Сохраняем токен в localStorage и устанавливаем его в состоянии
        if (data.data.token) {
          setAuthToken(data.data.token);
          localStorage.setItem('auth_token', data.data.token);
          console.log('[AuthContext] Токен сохранен в localStorage, длина:', data.data.token.length);
        }
        
        console.log('[AuthContext] Состояние после входа:', { 
          isAuthenticated: true, 
          userId: data.data.user?.id 
        });
        
        // Обновляем заголовок авторизации для всех последующих запросов
        if (data.data.token) {
          const authHeader = `Bearer ${data.data.token}`;
          console.log('[AuthContext] Устанавливаем заголовок авторизации для будущих запросов');
        }
        
        // Показываем уведомление об успешном входе
        toast.success('Вы успешно вошли в систему');

        // Перенаправляем пользователя в кабинет
        router.push('/cabinet');
        
        return true;
      }
      
      console.error('[AuthContext] Ошибка входа с помощью Telegram: неверный формат ответа от сервера');
      return false;
    } catch (error) {
      console.error('[AuthContext] Исключение при входе с помощью Telegram:', error);
      toast.error(error.message || 'Ошибка при входе');
      return false;
    }
  };

  // Мемоизируем значение контекста
  const contextValue = useMemo(
    () => ({
      user,
      isLoading,
      isAuthenticated,
      authToken,
      login,
      register,
      logout,
      refreshUser,
      getAuthToken,
      updateUserInfo,
      showLoginModal,
      loginWithTelegram,
    }),
    [user, isLoading, isAuthenticated, authToken, getAuthToken, showLoginModal, loginWithTelegram]
  );

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
};

// Вспомогательная функция для получения токена авторизации,
// которую можно использовать в любом месте приложения
export const getAuthTokenStatic = (): string | null => {
  // Проверяем localStorage
  if (typeof window !== 'undefined') {
    const token = localStorage.getItem('auth_token');
    if (token) return token;
    
    // Проверяем cookie через функцию getCookie
    const cookieToken = getCookie('auth_token');
    if (cookieToken) return cookieToken;
  }
  
  return null;
};

// Функции для проверки ролей пользователя
export function useIsAdmin() {
  const { user } = useAuth();
  return isAdmin(user);
}

export function useIsSpecialist() {
  const { user } = useAuth();
  return isSpecialist(user);
}

export function useUserRoleDisplay() {
  const { user } = useAuth();
  return user ? getUserRoleDisplayName(user.role) : '';
}