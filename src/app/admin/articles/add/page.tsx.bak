'use client';

import { useState, useRef, useCallback, useEffect } from 'react';
import { useAuth } from '@/lib/AuthContext';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import Image from 'next/image';
import {
  FaBold, FaItalic, FaUnderline, FaListUl, FaListOl, FaLink, FaQuoteRight, 
  FaCode, FaSave, FaTimes, FaImage, FaRobot, FaLightbulb, FaHeading, FaPlus,
  FaMagic, FaCheck, FaSpinner, FaPencilAlt, FaChevronDown, FaChevronRight, FaExclamationTriangle, FaUpload
} from 'react-icons/fa';
import { MdOutlineAutoFixHigh } from 'react-icons/md';
import RichTextEditor, { RichTextEditorRef } from '@/components/RichTextEditor';
import { toast } from '@/components/ui/Toast';

// Типы данных
type ArticleCategory = string;

interface Service {
  id: string;
  name: string;
  description?: string;
  shortDescription?: string;
  image?: string;
  price: number;
  duration: number;
  color?: string;
  order?: number;
  isArchived?: boolean;
  specialists?: any[];
  updatedAt?: string;
}

interface Specialist {
  id: string;
  firstName: string;
  lastName: string;
  photo?: string;
  specialization: string;
  // Другие свойства специалиста...
}

type FormData = {
  title: string;
  excerpt: string;
  content: string;
  category: ArticleCategory;
  image: File | null;
  imagePreview: string;
  status: 'draft' | 'published';
  specialistId: string;
  customCategory?: string;
};

// Компонент для категории статьи
const CategoryTag = ({ category }: { category: ArticleCategory }) => {
  const categoryMap: Record<string, { label: string, color: string }> = {
    'inspiration': { label: 'Вдохновение', color: 'bg-purple-100 text-purple-800' },
    // Динамические категории будут добавлены из услуг
  };
  
  const { label, color } = categoryMap[category] || { label: category, color: 'bg-gray-100 text-gray-800' };
  
  return (
    <span className={`px-2 py-1 inline-flex text-xs leading-5 font-semibold rounded-full ${color}`}>
      {label}
    </span>
  );
};

// Компонент для отображения состояния загрузки
const SkeletonLoader = () => (
  <div className="flex gap-2 items-center">
    <div className="w-4 h-4 rounded-full animate-pulse bg-gray-300"></div>
    <span className="text-gray-400">Загрузка категорий...</span>
  </div>
);

// Компонент модального окна для генерации обложки
const BannerGenerator = ({ 
  isOpen, 
  onClose, 
  onApplyImage 
}: { 
  isOpen: boolean; 
  onClose: () => void; 
  onApplyImage: (imageUrl: string) => void;
}) => {
  const [prompt, setPrompt] = useState('');
  const [generatedImageUrl, setGeneratedImageUrl] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState('');
  const [checkingStatus, setCheckingStatus] = useState(false);
  
  // Параметры для генерации изображений с FusionBrain
  const [imageWidth, setImageWidth] = useState<number>(768);
  const [imageHeight, setImageHeight] = useState<number>(432);
  const [imageStyle, setImageStyle] = useState<string>('DEFAULT');
  const [negativePrompt, setNegativePrompt] = useState<string>('');
  const [imageAspectRatio, setImageAspectRatio] = useState<string>('16:9');
  const [showAdvancedImageSettings, setShowAdvancedImageSettings] = useState(false);
  const [pipelineId, setPipelineId] = useState<string>('');
  const [generationUuid, setGenerationUuid] = useState<string>('');
  
  // API ключи для FusionBrain
  const FUSION_BRAIN_API_KEY = '80810B8110B4948751EE149B79323C97';
  const FUSION_BRAIN_SECRET_KEY = '82CD04179C21806452EE34C351A882F7';
  const FUSION_BRAIN_URL = 'https://api-key.fusionbrain.ai/';
  
  // Доступные стили для генерации изображений
  const imageStyles = [
    { name: 'DEFAULT', title: 'Свой стиль' },
    { name: 'KANDINSKY', title: 'Кандинский' },
    { name: 'UHD', title: 'Детальное фото' },
    { name: 'ANIME', title: 'Аниме' }
  ];
  
  // Соотношения сторон для изображений
  const aspectRatios = [
    { name: '1:1', width: 512, height: 512 },
    { name: '3:2', width: 768, height: 512 },
    { name: '2:3', width: 512, height: 768 },
    { name: '16:9', width: 768, height: 432 },
    { name: '9:16', width: 432, height: 768 }
  ];
  
  // Получаем pipeline_id при первой загрузке компонента
  useEffect(() => {
    if (isOpen && !pipelineId) {
      getPipelineId();
    }
  }, [isOpen, pipelineId]);
  
  // Функция для получения pipeline_id
  const getPipelineId = async () => {
    try {
      const headers = {
        'X-Key': `Key ${FUSION_BRAIN_API_KEY}`,
        'X-Secret': `Secret ${FUSION_BRAIN_SECRET_KEY}`
      };
      
      const response = await fetch(`${FUSION_BRAIN_URL}key/api/v1/pipelines`, {
        method: 'GET',
        headers
      });
      
      if (!response.ok) {
        throw new Error(`Ошибка при получении pipeline_id: ${response.status}`);
      }
      
      const data = await response.json();
      if (data && data.length > 0) {
        setPipelineId(data[0].id);
      } else {
        throw new Error('Не удалось получить pipeline_id');
      }
    } catch (err) {
      console.error('Ошибка при получении pipeline_id:', err);
      setError(`Ошибка инициализации API для генерации изображений: ${err instanceof Error ? err.message : 'Неизвестная ошибка'}`);
    }
  };
  
  // Функция для обновления размеров при изменении соотношения сторон
  const handleAspectRatioChange = (ratio: string) => {
    setImageAspectRatio(ratio);
    const selectedRatio = aspectRatios.find(r => r.name === ratio);
    if (selectedRatio) {
      setImageWidth(selectedRatio.width);
      setImageHeight(selectedRatio.height);
    }
  };
  
  // Функция для генерации изображений с FusionBrain API
  const generateBannerImage = async () => {
    if (!prompt.trim()) {
      setError('Пожалуйста, опишите обложку');
      return;
    }
    
    if (!pipelineId) {
      setError('API для генерации изображений не инициализирован. Попробуйте позже.');
      return;
    }
    
    setIsGenerating(true);
    setError('');
    setGeneratedImageUrl('');
    setGenerationUuid('');
    
    // Добавляем анимацию загрузки
    const loadingElement = document.getElementById('banner-generate-preview');
    if (loadingElement) {
      loadingElement.innerHTML = `
        <div class="flex flex-col items-center justify-center p-8 bg-gray-50 rounded-lg h-full">
          <div class="mb-4">
            <svg class="animate-spin h-12 w-12 text-[#48a9a6]" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
              <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
          </div>
          <p class="text-gray-700 text-center">Генерируем обложку для статьи...<br>Это может занять до 30 секунд</p>
        </div>
      `;
    }
    
    try {
      // Заголовки для авторизации
      const headers = {
        'X-Key': `Key ${FUSION_BRAIN_API_KEY}`,
        'X-Secret': `Secret ${FUSION_BRAIN_SECRET_KEY}`
      };
      
      // Параметры запроса
      const params = {
        type: 'GENERATE',
        numImages: 1,
        width: imageWidth,
        height: imageHeight,
        style: imageStyle,
        negativePromptDecoder: negativePrompt || undefined,
        generateParams: {
          query: prompt
        }
      };
      
      // Формируем FormData для отправки
      const formData = new FormData();
      formData.append('pipeline_id', pipelineId);
      formData.append('params', new Blob([JSON.stringify(params)], { type: 'application/json' }));
      
      // Отправляем запрос
      const response = await fetch(`${FUSION_BRAIN_URL}key/api/v1/pipeline/run`, {
        method: 'POST',
        headers,
        body: formData
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API вернул ошибку: ${response.status} - ${errorText}`);
      }
      
      const data = await response.json();
      
      if (data && data.uuid) {
        setGenerationUuid(data.uuid);
        // Начинаем проверять статус
        checkGenerationStatus(data.uuid);
      } else {
        throw new Error('Неожиданный формат ответа от API');
      }
    } catch (err) {
      console.error('Ошибка при генерации изображения:', err);
      setError(`Ошибка: ${err instanceof Error ? err.message : 'Что-то пошло не так'}`);
      setIsGenerating(false);
      
      // Сбрасываем анимацию загрузки
      const previewElement = document.getElementById('banner-generate-preview');
      if (previewElement) {
        previewElement.innerHTML = '<div class="flex items-center justify-center h-full bg-gray-100 rounded-lg"><span class="text-gray-400">Предпросмотр</span></div>';
      }
    }
  };
  
  // Функция для проверки статуса генерации изображения
  const checkGenerationStatus = async (uuid: string, attemptCount = 0) => {
    if (attemptCount > 20) {
      setError('Превышено время ожидания генерации изображения');
      setIsGenerating(false);
      setCheckingStatus(false);
      return;
    }
    
    setCheckingStatus(true);
    
    try {
      const headers = {
        'X-Key': `Key ${FUSION_BRAIN_API_KEY}`,
        'X-Secret': `Secret ${FUSION_BRAIN_SECRET_KEY}`
      };
      
      const response = await fetch(`${FUSION_BRAIN_URL}key/api/v1/pipeline/status/${uuid}`, {
        method: 'GET',
        headers
      });
      
      if (!response.ok) {
        throw new Error(`Ошибка при проверке статуса: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Обновляем анимацию с процентами выполнения (если есть)
      const previewElement = document.getElementById('banner-generate-preview');
      if (previewElement && data.status === 'PROCESSING' && data.progress) {
        const progressText = `Генерируем обложку... ${Math.round(data.progress * 100)}%`;
        previewElement.innerHTML = `
          <div class="flex flex-col items-center justify-center p-8 bg-gray-50 rounded-lg h-full">
            <div class="mb-4">
              <svg class="animate-spin h-12 w-12 text-[#48a9a6]" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
            </div>
            <p class="text-gray-700 text-center">${progressText}<br>Это может занять до 30 секунд</p>
          </div>
        `;
      }
      
      if (data.status === 'DONE') {
        // Изображение готово
        if (data.result && data.result.files && data.result.files.length > 0) {
          // Получаем base64 изображения
          const imageBase64 = data.result.files[0];
          
          // Сохраняем изображение на сервере
          try {
            const saveResponse = await fetch('/api/images/save', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                imageData: imageBase64,
                fileName: `banner_${Date.now()}.png`,
                altText: prompt
              }),
            });
            
            if (saveResponse.ok) {
              const { imageUrl } = await saveResponse.json();
              // Обновляем предпросмотр
              setGeneratedImageUrl(imageUrl);
              
              // Отображаем изображение в превью
              const previewElement = document.getElementById('banner-generate-preview');
              if (previewElement) {
                previewElement.innerHTML = `<img src="${imageUrl}" alt="${prompt}" class="object-cover w-full h-full rounded-lg" />`;
              }
            } else {
              // Если сохранить не удалось, используем оригинальный base64
              setGeneratedImageUrl(imageBase64);
              
              // Отображаем изображение в превью
              const previewElement = document.getElementById('banner-generate-preview');
              if (previewElement) {
                previewElement.innerHTML = `<img src="${imageBase64}" alt="${prompt}" class="object-cover w-full h-full rounded-lg" />`;
              }
            }
          } catch (saveError) {
            console.error('Ошибка при сохранении изображения:', saveError);
            // В случае ошибки, все равно показываем изображение как base64
            setGeneratedImageUrl(imageBase64);
            
            // Отображаем изображение в превью
            const previewElement = document.getElementById('banner-generate-preview');
            if (previewElement) {
              previewElement.innerHTML = `<img src="${imageBase64}" alt="${prompt}" class="object-cover w-full h-full rounded-lg" />`;
            }
          }
        } else {
          throw new Error('Изображение сгенерировано, но не получено');
        }
        
        setIsGenerating(false);
        setCheckingStatus(false);
      } else if (data.status === 'FAIL') {
        // Ошибка генерации
        throw new Error(`Ошибка генерации изображения: ${data.errorDescription || 'Неизвестная ошибка'}`);
      } else {
        // Продолжаем проверять
        setTimeout(() => {
          checkGenerationStatus(uuid, attemptCount + 1);
        }, 2000); // Проверяем каждые 2 секунды
      }
    } catch (err) {
      console.error('Ошибка при проверке статуса генерации:', err);
      setError(`Ошибка: ${err instanceof Error ? err.message : 'Что-то пошло не так'}`);
      setIsGenerating(false);
      setCheckingStatus(false);
      
      // Сбрасываем анимацию загрузки
      const previewElement = document.getElementById('banner-generate-preview');
      if (previewElement) {
        previewElement.innerHTML = '<div class="flex items-center justify-center h-full bg-gray-100 rounded-lg"><span class="text-gray-400">Предпросмотр</span></div>';
      }
    }
  };
  
  // Применение сгенерированного изображения
  const applyGeneratedImage = () => {
    if (generatedImageUrl) {
      onApplyImage(generatedImageUrl);
      onClose();
    }
  };
  
  // Если модальное окно закрыто, не рендерим ничего
  if (!isOpen) return null;
  
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
      <div className="bg-white rounded-xl shadow-xl w-full max-w-3xl max-h-[90vh] flex flex-col">
        <div className="flex items-center justify-between p-4 border-b">
          <h3 className="text-xl font-semibold text-gray-800 flex items-center">
            <FaImage className="mr-2 text-[#48a9a6]" /> 
            Генерация обложки для статьи
          </h3>
          <button
            onClick={onClose}
            className="text-gray-500 hover:text-gray-700 transition-colors"
          >
            <FaTimes size={20} />
          </button>
        </div>
        
        <div className="p-4 grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="flex flex-col">
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Описание обложки
              </label>
              <textarea
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
                placeholder="Опишите, какую обложку вы хотите сгенерировать. Например: Закат над озером в горах, яркие цвета"
                className="w-full px-4 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-[#48a9a6] focus:border-transparent"
                rows={3}
              />
            </div>
            
            <div className="mb-4">
              <div className="flex flex-wrap gap-2 mb-2">
                <div className="flex-grow">
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Стиль изображения
                  </label>
                  <select
                    value={imageStyle}
                    onChange={(e) => setImageStyle(e.target.value)}
                    className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-[#48a9a6] focus:border-transparent"
                  >
                    {imageStyles.map(style => (
                      <option key={style.name} value={style.name}>{style.title}</option>
                    ))}
                  </select>
                </div>
                
                <div className="flex-grow">
                  <label className="block text-sm font-medium text-gray-700 mb-2">
                    Соотношение сторон
                  </label>
                  <select
                    value={imageAspectRatio}
                    onChange={(e) => handleAspectRatioChange(e.target.value)}
                    className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-[#48a9a6] focus:border-transparent"
                  >
                    {aspectRatios.map(ratio => (
                      <option key={ratio.name} value={ratio.name}>{ratio.name} ({ratio.width}×{ratio.height})</option>
                    ))}
                  </select>
                </div>
              </div>
            </div>
            
            <button
              onClick={() => setShowAdvancedImageSettings(!showAdvancedImageSettings)}
              className="text-sm text-[#48a9a6] mb-3 mt-1 flex items-center"
            >
              {showAdvancedImageSettings ? '▼' : '►'} Расширенные настройки
            </button>
            
            {showAdvancedImageSettings && (
              <div className="bg-gray-50 p-3 rounded-lg mb-3">
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Негативный промпт (что исключить из изображения)
                </label>
                <textarea
                  value={negativePrompt}
                  onChange={(e) => setNegativePrompt(e.target.value)}
                  placeholder="Например: размытость, искажения, низкое качество"
                  className="w-full px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-[#48a9a6] focus:border-transparent"
                  rows={2}
                />
                
                <div className="flex flex-wrap gap-4 mt-3">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Ширина (px)
                    </label>
                    <input
                      type="number"
                      value={imageWidth}
                      onChange={(e) => setImageWidth(parseInt(e.target.value))}
                      min={128}
                      max={1024}
                      step={64}
                      className="w-24 px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-[#48a9a6] focus:border-transparent"
                    />
                  </div>
                  
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Высота (px)
                    </label>
                    <input
                      type="number"
                      value={imageHeight}
                      onChange={(e) => setImageHeight(parseInt(e.target.value))}
                      min={128}
                      max={1024}
                      step={64}
                      className="w-24 px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-[#48a9a6] focus:border-transparent"
                    />
                  </div>
                </div>
                
                <div className="text-xs text-gray-500 mt-2">
                  Рекомендуется использовать значения, кратные 64. Максимальный размер: 1024×1024
                </div>
              </div>
            )}
            
            {error && <p className="mt-1 text-sm text-red-500">{error}</p>}
            
            <div className="mt-auto">
              <button
                onClick={generateBannerImage}
                disabled={isGenerating || !prompt.trim()}
                className={`w-full px-4 py-2 rounded-lg bg-[#48a9a6] text-white flex items-center justify-center ${
                  isGenerating || !prompt.trim() ? 'opacity-50 cursor-not-allowed' : 'hover:bg-[#48a9a6]/90'
                }`}
              >
                {isGenerating ? (
                  <>
                    <FaSpinner className="mr-2 animate-spin" /> 
                    {checkingStatus ? 'Ожидание результата...' : 'Генерация...'}
                  </>
                ) : (
                  <>
                    <FaMagic className="mr-2" /> 
                    Сгенерировать обложку
                  </>
                )}
              </button>
            </div>
          </div>
          
          <div className="flex flex-col">
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Предпросмотр изображения
            </label>
            <div 
              id="banner-generate-preview"
              className="w-full h-64 border border-gray-200 rounded-lg overflow-hidden mb-4"
            >
              <div className="flex items-center justify-center h-full bg-gray-100 rounded-lg">
                <span className="text-gray-400">Предпросмотр</span>
              </div>
            </div>
            
            <button
              onClick={applyGeneratedImage}
              disabled={!generatedImageUrl || isGenerating}
              className={`w-full px-4 py-2 rounded-lg bg-[#48a9a6] text-white flex items-center justify-center mt-auto ${
                !generatedImageUrl || isGenerating ? 'opacity-50 cursor-not-allowed' : 'hover:bg-[#48a9a6]/90'
              }`}
            >
              <FaCheck className="mr-2" /> 
              Применить как обложку
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

// Компонент модального окна ИИ-дополнения (VPN)
const AIWritingAssistant = ({ 
  isOpen, 
  onClose, 
  onApplyText,
  onAppendText,
  currentContent 
}: { 
  isOpen: boolean; 
  onClose: () => void; 
  onApplyText: (text: string) => void;
  onAppendText: (text: string) => void;
  currentContent: string;
}) => {
  const [prompt, setPrompt] = useState('');
  const [generatedContent, setGeneratedContent] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState('');
  const [mode, setMode] = useState<'generate' | 'improve' | 'ideas' | 'image'>('generate');
  const [improveOption, setImproveOption] = useState<string>('grammar');
  
  // Отдельные состояния для каждого режима работы
  const [generateContent, setGenerateContent] = useState('');
  const [improveContent, setImproveContent] = useState('');
  const [ideasContent, setIdeasContent] = useState('');
  const [imageContent, setImageContent] = useState('');
  
  // Параметры для генерации изображений с FusionBrain
  const [imageWidth, setImageWidth] = useState<number>(512);
  const [imageHeight, setImageHeight] = useState<number>(512);
  const [imageStyle, setImageStyle] = useState<string>('DEFAULT');
  const [negativePrompt, setNegativePrompt] = useState<string>('');
  const [imageAspectRatio, setImageAspectRatio] = useState<string>('1:1');
  const [showAdvancedImageSettings, setShowAdvancedImageSettings] = useState(false);
  const [pipelineId, setPipelineId] = useState<string>('');
  const [generationUuid, setGenerationUuid] = useState<string>('');
  const [checkingStatus, setCheckingStatus] = useState(false);
  
  // Обновляем generatedContent при изменении режима работы
  useEffect(() => {
    console.log('Режим изменился на:', mode);
    console.log('Состояния содержимого:', {
      generate: generateContent ? 'есть содержимое' : 'пусто',
      improve: improveContent ? 'есть содержимое' : 'пусто',
      ideas: ideasContent ? 'есть содержимое' : 'пусто',
      image: imageContent ? 'есть содержимое' : 'пусто'
    });
    
    switch(mode) {
      case 'generate':
        setGeneratedContent(generateContent);
        break;
      case 'improve':
        setGeneratedContent(improveContent);
        break;
      case 'ideas':
        setGeneratedContent(ideasContent);
        break;
      case 'image':
        setGeneratedContent(imageContent);
        break;
    }
  }, [mode, generateContent, improveContent, ideasContent, imageContent]);
  
  // API ключи для FusionBrain
  const FUSION_BRAIN_API_KEY = '80810B8110B4948751EE149B79323C97';
  const FUSION_BRAIN_SECRET_KEY = '82CD04179C21806452EE34C351A882F7';
  const FUSION_BRAIN_URL = 'https://api-key.fusionbrain.ai/';
  
  // Доступные стили для генерации изображений
  const imageStyles = [
    { name: 'DEFAULT', title: 'Свой стиль' },
    { name: 'KANDINSKY', title: 'Кандинский' },
    { name: 'UHD', title: 'Детальное фото' },
    { name: 'ANIME', title: 'Аниме' }
  ];
  
  // Соотношения сторон для изображений
  const aspectRatios = [
    { name: '1:1', width: 512, height: 512 },
    { name: '3:2', width: 768, height: 512 },
    { name: '2:3', width: 512, height: 768 },
    { name: '16:9', width: 768, height: 432 },
    { name: '9:16', width: 432, height: 768 }
  ];
  
  // Получаем pipeline_id при первой загрузке компонента
  useEffect(() => {
    if (mode === 'image' && !pipelineId) {
      getPipelineId();
    }
  }, [mode, pipelineId]);
  
  // Функция для получения pipeline_id
  const getPipelineId = async () => {
    try {
      const headers = {
        'X-Key': `Key ${FUSION_BRAIN_API_KEY}`,
        'X-Secret': `Secret ${FUSION_BRAIN_SECRET_KEY}`
      };
      
      const response = await fetch(`${FUSION_BRAIN_URL}key/api/v1/pipelines`, {
        method: 'GET',
        headers
      });
      
      if (!response.ok) {
        throw new Error(`Ошибка при получении pipeline_id: ${response.status}`);
      }
      
      const data = await response.json();
      if (data && data.length > 0) {
        setPipelineId(data[0].id);
      } else {
        throw new Error('Не удалось получить pipeline_id');
      }
    } catch (err) {
      console.error('Ошибка при получении pipeline_id:', err);
      setError(`Ошибка инициализации API для генерации изображений: ${err instanceof Error ? err.message : 'Неизвестная ошибка'}`);
    }
  };
  
  // Функция для обновления размеров при изменении соотношения сторон
  const handleAspectRatioChange = (ratio: string) => {
    setImageAspectRatio(ratio);
    const selectedRatio = aspectRatios.find(r => r.name === ratio);
    if (selectedRatio) {
      setImageWidth(selectedRatio.width);
      setImageHeight(selectedRatio.height);
    }
  };
  
  // Варианты улучшения текста
  const improveOptions = [
    { id: 'grammar', title: 'Грамматика и стиль', prompt: 'Улучши грамматику, стиль и читаемость следующего текста. Исправь ошибки, улучши формулировки, но сохрани смысл и основное содержание.' },
    { id: 'expand', title: 'Расширить', prompt: 'Расширь следующий текст, добавив больше деталей, примеров и пояснений. Сделай текст более информативным и полным.' },
    { id: 'simplify', title: 'Упростить', prompt: 'Упрости следующий текст, сделай его более понятным и легким для чтения. Используй более простые слова и короткие предложения, сохраняя основную информацию.' },
    { id: 'rewrite', title: 'Переписать', prompt: 'Полностью перепиши следующий текст, сохраняя основной смысл и ключевые моменты, но используя другие слова и структуру.' },
    { id: 'custom', title: 'Свой вариант', prompt: '' }
  ];
  
  // Примеры промптов для разных режимов
  const promptExamples = {
    generate: 'Напиши статью о преимуществах медитации для снятия стресса',
    improve: 'Дополнительные указания (необязательно)',
    ideas: 'Предложи 5 идей для статьи о здоровом образе жизни',
    image: 'Закат над горами с озером на переднем плане, реалистичный стиль'
  };

  // Функция для работы с API Gemini для текста
  const generateWithAI = async () => {
    if (!prompt.trim() && (mode !== 'improve' || improveOption === 'custom')) {
      setError('Пожалуйста, введите запрос для ИИ');
      return;
    }
    
    setIsGenerating(true);
    setError('');
    
    try {
      console.log('Генерация начата. Режим:', mode, 'Промпт:', prompt);
      let promptToSend = prompt;
      
      // Формируем запрос в зависимости от выбранного режима
      if (mode === 'improve' && currentContent) {
        // Выбираем подходящий промпт для улучшения текста
        let improvePrompt = '';
        if (improveOption === 'custom') {
          improvePrompt = prompt;
        } else {
          const selectedOption = improveOptions.find(opt => opt.id === improveOption);
          improvePrompt = selectedOption ? selectedOption.prompt : '';
          if (prompt.trim()) {
            improvePrompt += ' ' + prompt;
          }
        }
        
        promptToSend = `${improvePrompt}\n\nВот текст, который нужно улучшить:\n${currentContent}`;
      } else if (mode === 'ideas') {
        promptToSend = `Предложи идеи для статьи на тему: ${promptToSend}. Дай несколько вариантов заголовков и структуры.`;
      } else if (mode === 'generate') {
        promptToSend = `Напиши профессиональную статью для блога на тему: ${promptToSend}. 
          
Требования:
1. Используй HTML-разметку для структурирования контента: заголовки h2 и h3, параграфы p, списки ul/li, жирный текст (strong), курсив (em).
2. Не используй никаких внешних тегов html, body, head, style, script и т.д. - только содержимое статьи.
3. Статья должна быть информативной и полезной, содержать практические советы.
4. Добавь подзаголовки для разделения текста на логические части.
5. Добавь вступление, основную часть и заключение.
6. Не нужно никаких комментариев или пояснений к HTML коду.
7. Не включай фразы типа "Вот статья", "Надеюсь, эта статья поможет" или подобные.

Пример правильного формата:
<h2>Заголовок статьи</h2>
<p>Текст вступления...</p>
<h3>Подзаголовок</h3>
<p>Основной текст...</p>`;
      } else if (mode === 'image') {
        // Для изображений используем API FusionBrain
        generateImageWithFusionBrain();
        return;
      }
      
      console.log('Отправляемый запрос к Gemini:', promptToSend.substring(0, 100) + '...');
      
      // Используем модель gemini-2.0-flash, которая доступна с текущим API ключом
      const apiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=AIzaSyCv6hKJNiZ5_CuMA007vcrNx374wK67hY4';
      console.log('API URL:', apiUrl);
      
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{ text: promptToSend }]
          }]
        }),
      });
      
      // Отладочное логирование статуса ответа API
      console.log('Gemini API response status:', response.status);
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Gemini API error response:', errorText);
        throw new Error(`API вернул ошибку: ${response.status} - ${errorText}`);
      }
      
      const data = await response.json();
      
      // Добавляем отладочное логирование данных API
      console.log('Gemini API response data:', JSON.stringify(data).substring(0, 200) + '...');
      
      if (
        data &&
        data.candidates &&
        data.candidates.length > 0 &&
        data.candidates[0].content &&
        data.candidates[0].content.parts &&
        data.candidates[0].content.parts.length > 0 &&
        data.candidates[0].content.parts[0].text
      ) {
        let generatedText = data.candidates[0].content.parts[0].text;
        console.log('Получен ответ. Длина текста:', generatedText.length);
        
        // Удаляем все метаданные и пояснения, если они есть
        if (mode === 'generate') {
          console.log('Обрабатываем ответ для режима "Написать статью". Текст до обработки:', generatedText.substring(0, 200) + '...');
          
          // Если текст содержит блок кода с HTML, извлекаем его
          const htmlCodeBlockMatch = generatedText.match(/```(?:html)?\s*([\s\S]*?)```/);
          if (htmlCodeBlockMatch && htmlCodeBlockMatch[1]) {
            console.log('Обнаружен HTML в блоке кода, извлекаем содержимое');
            generatedText = htmlCodeBlockMatch[1];
          }
          
          // Удаляем блоки с пояснениями в формате Markdown
          generatedText = generatedText.replace(/```[\s\S]*?```/g, '');
          
          // Удаляем любые пояснения, заключенные в звездочки или в скобки
          generatedText = generatedText.replace(/\*\*Пояснения:?\*\*[\s\S]*?(?=<|$)/g, '');
          generatedText = generatedText.replace(/\*\*Важно:?\*\*[\s\S]*?(?=<|$)/g, '');
          generatedText = generatedText.replace(/\*\*Как использовать[\s\S]*?(?=<|$)/g, '');
          generatedText = generatedText.replace(/\*\*HTML-структура:?\*\*[\s\S]*?(?=<|$)/g, '');
          generatedText = generatedText.replace(/\*\*Стили:?\*\*[\s\S]*?(?=<|$)/g, '');
          generatedText = generatedText.replace(/\*\*Изображения:?\*\*[\s\S]*?(?=<|$)/g, '');
          generatedText = generatedText.replace(/\*\*Контент:?\*\*[\s\S]*?(?=<|$)/g, '');
          generatedText = generatedText.replace(/\*\*Классы:?\*\*[\s\S]*?(?=<|$)/g, '');
          generatedText = generatedText.replace(/\(\s*Примечание:[\s\S]*?\)/g, '');
          generatedText = generatedText.replace(/\(\s*Примечание автора:[\s\S]*?\)/g, '');
          generatedText = generatedText.replace(/Надеюсь, эта статья[\s\S]*?$/m, '');
          
          // Удаляем строки, начинающиеся с чисел и точек (списки пояснений)
          generatedText = generatedText.replace(/^\d+\.\s+.*$/gm, '');
          
          // Удаляем пустые строки, которые могли остаться после удаления пояснений
          generatedText = generatedText.replace(/\n\s*\n+/g, '\n\n');
          
          // Удаляем пояснения в начале и конце
          generatedText = generatedText.replace(/^(Вот статья|Статья)[\s\S]*?(?=<)/g, '');
          generatedText = generatedText.replace(/^[\s\S]*?(Вот|Это) (готовая статья|статья)[\s\S]*?(?=<)/g, '');
          
          // Удаляем тег DOCTYPE, html, head и body, если они есть
          generatedText = generatedText.replace(/<!DOCTYPE[^>]*>/i, '');
          generatedText = generatedText.replace(/<html[^>]*>|<\/html>/gi, '');
          generatedText = generatedText.replace(/<head>[\s\S]*?<\/head>/gi, '');
          generatedText = generatedText.replace(/<body[^>]*>|<\/body>/gi, '');
          
          // Удаляем теги style, если они есть
          generatedText = generatedText.replace(/<style>[\s\S]*?<\/style>/gi, '');
          
          // Если текст не содержит HTML-тегов, оборачиваем его в параграфы
          if (!generatedText.includes('<') && !generatedText.includes('>')) {
            generatedText = '<p>' + generatedText.replace(/\n\n/g, '</p><p>') + '</p>';
          }
          
          console.log('Текст после обработки:', generatedText.substring(0, 200) + '...');
        } else if (mode === 'improve' || mode === 'ideas') {
          // Для других режимов проверяем, содержит ли текст HTML-форматирование
          if (!generatedText.includes('<') && !generatedText.includes('>')) {
            // Если текст не имеет HTML-форматирования, добавляем его
            generatedText = '<p>' + generatedText.replace(/\n\n/g, '</p><p>').replace(/\n/g, '<br>') + '</p>';
          }
        }
        
        // Убеждаемся, что контент имеет базовую HTML-структуру
        if (!generatedText.trim().startsWith('<')) {
          generatedText = '<p>' + generatedText + '</p>';
        }
        
        // Сохраняем результат в соответствующем состоянии
        const trimmedText = generatedText.trim();
        console.log('Текст обработан. Итоговая длина:', trimmedText.length);
        
        // Сначала обновляем состояние для соответствующего режима
        if (mode === 'generate') {
          setGenerateContent(trimmedText);
        } else if (mode === 'improve') {
          setImproveContent(trimmedText);
        } else if (mode === 'ideas') {
          setIdeasContent(trimmedText);
        }
        
        // Затем обновляем текущее отображаемое содержимое
        setGeneratedContent(trimmedText);
      } else {
        console.error('Неожиданный формат ответа от API:', data);
        throw new Error('Неожиданный формат ответа от API');
      }
    } catch (err) {
      console.error('Ошибка при генерации текста:', err);
      setError(`Ошибка: ${err instanceof Error ? err.message : 'Что-то пошло не так'}`);
    } finally {
      setIsGenerating(false);
    }
  };
  
  // Функция для генерации изображений с FusionBrain API
  const generateImageWithFusionBrain = async () => {
    if (!prompt.trim()) {
      setError('Пожалуйста, опишите изображение');
      return;
    }
    
    if (!pipelineId) {
      setError('API для генерации изображений не инициализирован. Попробуйте позже.');
      return;
    }
    
    setIsGenerating(true);
    setError('');
    setGeneratedContent('');
    setGenerationUuid('');
    
    // Добавляем анимацию загрузки
    const loadingAnimation = `
      <div class="flex flex-col items-center justify-center p-8 bg-gray-50 rounded-lg">
        <div class="mb-4">
          <svg class="animate-spin h-12 w-12 text-[#48a9a6]" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
        </div>
        <p class="text-gray-700 text-center">Генерируем изображение по вашему запросу...<br>Это может занять до 30 секунд</p>
      </div>
    `;
    setGeneratedContent(loadingAnimation);
    setImageContent(loadingAnimation); // Сохраняем состояние загрузки и в imageContent
    
    try {
      // Заголовки для авторизации
      const headers = {
        'X-Key': `Key ${FUSION_BRAIN_API_KEY}`,
        'X-Secret': `Secret ${FUSION_BRAIN_SECRET_KEY}`
      };
      
      // Параметры запроса
      const params = {
        type: 'GENERATE',
        numImages: 1,
        width: imageWidth,
        height: imageHeight,
        style: imageStyle,
        negativePromptDecoder: negativePrompt || undefined,
        generateParams: {
          query: prompt
        }
      };
      
      // Формируем FormData для отправки
      const formData = new FormData();
      formData.append('pipeline_id', pipelineId);
      formData.append('params', new Blob([JSON.stringify(params)], { type: 'application/json' }));
      
      // Отправляем запрос
      const response = await fetch(`${FUSION_BRAIN_URL}key/api/v1/pipeline/run`, {
        method: 'POST',
        headers,
        body: formData
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API вернул ошибку: ${response.status} - ${errorText}`);
      }
      
      const data = await response.json();
      
      if (data && data.uuid) {
        setGenerationUuid(data.uuid);
        // Начинаем проверять статус
        checkGenerationStatus(data.uuid);
      } else {
        throw new Error('Неожиданный формат ответа от API');
      }
    } catch (err) {
      console.error('Ошибка при генерации изображения:', err);
      setError(`Ошибка: ${err instanceof Error ? err.message : 'Что-то пошло не так'}`);
      setIsGenerating(false);
      setGeneratedContent('');
    }
  };
  
  // Функция для проверки статуса генерации изображения
  const checkGenerationStatus = async (uuid: string, attemptCount = 0) => {
    if (attemptCount > 20) {
      setError('Превышено время ожидания генерации изображения');
      setIsGenerating(false);
      setCheckingStatus(false);
      setGeneratedContent('');
      return;
    }
    
    setCheckingStatus(true);
    
    try {
      const headers = {
        'X-Key': `Key ${FUSION_BRAIN_API_KEY}`,
        'X-Secret': `Secret ${FUSION_BRAIN_SECRET_KEY}`
      };
      
      const response = await fetch(`${FUSION_BRAIN_URL}key/api/v1/pipeline/status/${uuid}`, {
        method: 'GET',
        headers
      });
      
      if (!response.ok) {
        throw new Error(`Ошибка при проверке статуса: ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.status === 'DONE') {
        // Изображение готово
        if (data.result && data.result.files && data.result.files.length > 0) {
          // Получаем base64 изображения
          const imageBase64 = data.result.files[0];
          
          // Сохраняем изображение на сервере
          try {
            const saveResponse = await fetch('/api/images/save', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                imageData: imageBase64,
                fileName: `ai_generated_${Date.now()}.png`,
                altText: prompt
              }),
            });
            
            if (saveResponse.ok) {
              const { imageUrl } = await saveResponse.json();
              
              // Создаем HTML для отображения изображения с использованием сохраненного URL
              const imgHtml = `<img src="${imageUrl}" alt="${prompt}" style="max-width: 100%; height: auto; margin: 0 auto; display: block;">`;
              setGeneratedContent(imgHtml);
              setImageContent(imgHtml); // Сохраняем результат в imageContent
            } else {
              // Если сохранить не удалось, используем оригинальный base64
              const imgHtml = `<img src="${imageBase64}" alt="${prompt}" style="max-width: 100%; height: auto; margin: 0 auto; display: block;">`;
              setGeneratedContent(imgHtml);
              setImageContent(imgHtml); // Сохраняем результат в imageContent
            }
          } catch (saveError) {
            console.error('Ошибка при сохранении изображения:', saveError);
            // В случае ошибки, все равно показываем изображение как base64
            const imgHtml = `<img src="${imageBase64}" alt="${prompt}" style="max-width: 100%; height: auto; margin: 0 auto; display: block;">`;
            setGeneratedContent(imgHtml);
            setImageContent(imgHtml); // Сохраняем результат в imageContent
          }
        } else {
          throw new Error('Изображение сгенерировано, но не получено');
        }
        
        setIsGenerating(false);
        setCheckingStatus(false);
      } else if (data.status === 'FAIL') {
        // Ошибка генерации
        throw new Error(`Ошибка генерации изображения: ${data.errorDescription || 'Неизвестная ошибка'}`);
      } else {
        // Обновляем анимацию с процентами выполнения (если есть)
        let progressText = "Генерируем изображение...";
        if (data.status === 'PROCESSING' && data.progress) {
          progressText = `Генерируем изображение... ${Math.round(data.progress * 100)}%`;
        }
        
        const loadingHtml = `
          <div class="flex flex-col items-center justify-center p-8 bg-gray-50 rounded-lg">
            <div class="mb-4">
              <svg class="animate-spin h-12 w-12 text-[#48a9a6]" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
            </div>
            <p class="text-gray-700 text-center">${progressText}<br>Это может занять до 30 секунд</p>
          </div>
        `;
        setGeneratedContent(loadingHtml);
        setImageContent(loadingHtml); // Сохраняем промежуточное состояние и в imageContent
        
        // Продолжаем проверять
        setTimeout(() => {
          checkGenerationStatus(uuid, attemptCount + 1);
        }, 2000); // Проверяем каждые 2 секунды
      }
    } catch (err) {
      console.error('Ошибка при проверке статуса генерации:', err);
      setError(`Ошибка: ${err instanceof Error ? err.message : 'Что-то пошло не так'}`);
      setIsGenerating(false);
      setCheckingStatus(false);
      setGeneratedContent('');
    }
  };
  
  // Если модальное окно закрыто, не рендерим ничего
  if (!isOpen) return null;
  
  // Обработчик переключения режимов
  const handleModeChange = (newMode: 'generate' | 'improve' | 'ideas' | 'image') => {
    console.log('Переключение режима с', mode, 'на', newMode);
    setMode(newMode);
    setError('');
    // При смене режима очищаем промпт для предотвращения случайного повторного использования
    setPrompt('');
    
    // Если переключаемся на режим изображения, проверяем наличие pipeline_id
    if (newMode === 'image' && !pipelineId) {
      getPipelineId();
    }
  };
  
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4 overflow-auto">
      <div className="bg-white rounded-xl shadow-2xl w-full max-w-5xl max-h-[90vh] flex flex-col">
        <div className="flex items-center justify-between p-4 border-b bg-[#48a9a6] text-white rounded-t-xl">
          <h3 className="text-xl font-semibold flex items-center">
            <FaRobot className="mr-2" /> 
            ИИ-помощник (дополнительный)
          </h3>
          <button
            onClick={onClose}
            className="text-white hover:text-gray-200 transition-colors"
          >
            <FaTimes size={20} />
          </button>
        </div>
        
        <div className="flex flex-col md:flex-row h-full overflow-hidden">
          <div className="w-full md:w-1/3 p-4 border-r overflow-y-auto">
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Выберите режим работы
              </label>
              <div className="grid grid-cols-2 gap-2 mb-4">
                <button
                  onClick={() => setMode('generate')}
                  className={`py-2 px-3 text-sm rounded-lg flex items-center justify-center ${
                    mode === 'generate' 
                      ? 'bg-orange-500 text-white' 
                      : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                  }`}
                >
                  <FaPencilAlt className="mr-2 text-xs" /> Статья
                </button>
                <button
                  onClick={() => setMode('improve')}
                  className={`py-2 px-3 text-sm rounded-lg flex items-center justify-center ${
                    mode === 'improve' 
                      ? 'bg-orange-500 text-white' 
                      : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                  }`}
                >
                  <MdOutlineAutoFixHigh className="mr-2" /> Улучшить
                </button>
                <button
                  onClick={() => setMode('ideas')}
                  className={`py-2 px-3 text-sm rounded-lg flex items-center justify-center ${
                    mode === 'ideas' 
                      ? 'bg-orange-500 text-white' 
                      : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                  }`}
                >
                  <FaLightbulb className="mr-2 text-xs" /> Идеи
                </button>
                <button
                  onClick={() => setMode('image')}
                  className={`py-2 px-3 text-sm rounded-lg flex items-center justify-center ${
                    mode === 'image' 
                      ? 'bg-orange-500 text-white' 
                      : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                  }`}
                >
                  <FaImage className="mr-2 text-xs" /> Изображение
                </button>
              </div>
            </div>
            
            {mode === 'improve' && (
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Способ улучшения
                </label>
                <select 
                  value={improveOption}
                  onChange={(e) => setImproveOption(e.target.value)}
                  className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                >
                  {improveOptions.map(option => (
                    <option key={option.id} value={option.id}>
                      {option.title}
                    </option>
                  ))}
                </select>
              </div>
            )}
            
            {mode === 'image' && (
              <div className="mb-4">
                <div className="flex justify-between items-center mb-2">
                  <label className="block text-sm font-medium text-gray-700">
                    Стиль изображения
                  </label>
                  <button
                    type="button"
                    onClick={() => setShowAdvancedImageSettings(!showAdvancedImageSettings)}
                    className="text-xs text-orange-500 hover:text-orange-700 flex items-center"
                  >
                    {showAdvancedImageSettings ? <FaChevronDown className="mr-1" /> : <FaChevronRight className="mr-1" />}
                    {showAdvancedImageSettings ? 'Скрыть настройки' : 'Дополнительные настройки'}
                  </button>
                </div>
                
                <select 
                  value={imageStyle}
                  onChange={(e) => setImageStyle(e.target.value)}
                  className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500 mb-3"
                >
                  {imageStyles.map(style => (
                    <option key={style.name} value={style.name}>
                      {style.title}
                    </option>
                  ))}
                </select>
                
                <div className="mb-2">
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Соотношение сторон
                  </label>
                  <div className="flex flex-wrap gap-2">
                    {aspectRatios.map(ratio => (
                      <button
                        key={ratio.name}
                        type="button"
                        onClick={() => {
                          setImageAspectRatio(ratio.name);
                          setImageWidth(ratio.width);
                          setImageHeight(ratio.height);
                        }}
                        className={`px-3 py-1 text-xs rounded ${
                          imageAspectRatio === ratio.name
                            ? 'bg-orange-500 text-white'
                            : 'bg-gray-100 text-gray-800 hover:bg-gray-200'
                        }`}
                      >
                        {ratio.name}
                      </button>
                    ))}
                  </div>
                </div>
                
                {showAdvancedImageSettings && (
                  <div className="mb-3">
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Негативный промпт
                    </label>
                    <textarea
                      value={negativePrompt}
                      onChange={(e) => setNegativePrompt(e.target.value)}
                      placeholder="Введите, что НЕ должно быть на изображении"
                      className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                      rows={2}
                    />
                    
                    <div className="flex gap-4 mt-3">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                          Ширина (px)
                        </label>
                        <input
                          type="number"
                          value={imageWidth}
                          onChange={(e) => setImageWidth(parseInt(e.target.value))}
                          min={128}
                          max={1024}
                          step={64}
                          className="w-24 px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                          Высота (px)
                        </label>
                        <input
                          type="number"
                          value={imageHeight}
                          onChange={(e) => setImageHeight(parseInt(e.target.value))}
                          min={128}
                          max={1024}
                          step={64}
                          className="w-24 px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                        />
                      </div>
                    </div>
                    
                    <div className="text-xs text-gray-500 mt-2">
                      Рекомендуется использовать значения, кратные 64. Максимальный размер: 1024×1024
                    </div>
                  </div>
                )}
              </div>
            )}
            
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                {mode === 'generate' ? 'Опишите желаемую статью' : 
                 mode === 'improve' ? 'Дополнительные указания (опционально)' : 
                 mode === 'ideas' ? 'Тема для идей' : 
                 'Опишите желаемое изображение'}
              </label>
              <textarea
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
                placeholder={mode === 'generate' ? 'Например: Здоровые привычки для повышения продуктивности' : 
                             mode === 'improve' ? 'Например: Сделать текст более энергичным' : 
                             mode === 'ideas' ? 'Например: Тренды в веб-дизайне' : 
                             'Например: Закат над горами с озером на переднем плане, реалистичный стиль'}
                className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                rows={5}
              />
            </div>
            
            {error && (
              <div className="mt-2 mb-4 p-3 bg-red-50 text-red-700 rounded-lg flex items-start">
                <FaExclamationTriangle className="mt-1 mr-2 flex-shrink-0" />
                <div>{error}</div>
              </div>
            )}
            
            <div className="mt-auto">
              <button
                onClick={generateWithAI}
                disabled={isGenerating || (mode !== 'improve' && !prompt.trim()) || (mode === 'improve' && !currentContent && !prompt.trim())}
                className={`w-full py-2 rounded-lg flex items-center justify-center 
                  ${isGenerating || (mode !== 'improve' && !prompt.trim()) || (mode === 'improve' && !currentContent && !prompt.trim())
                    ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                    : 'bg-orange-500 text-white hover:bg-orange-600'
                  }`}
              >
                {isGenerating ? (
                  <>
                    <FaSpinner className="animate-spin mr-2" />
                    {checkingStatus ? 'Ожидание...' : 'Генерация...'}
                  </>
                ) : (
                  <>
                    {mode === 'generate' ? <FaPencilAlt className="mr-2" /> : 
                    mode === 'improve' ? <MdOutlineAutoFixHigh className="mr-2" /> : 
                    mode === 'ideas' ? <FaLightbulb className="mr-2" /> : 
                    <FaImage className="mr-2" />}
                    {mode === 'generate' ? 'Написать статью' : 
                    mode === 'improve' ? 'Улучшить текст' : 
                    mode === 'ideas' ? 'Предложить идеи' : 
                    'Создать изображение'}
                  </>
                )}
              </button>
            </div>
          </div>
          
          <div className="w-full md:w-2/3 p-4 flex flex-col h-full overflow-hidden">
            <h3 className="text-lg font-medium text-gray-800 mb-2">Результат</h3>
            
            <div className="flex-grow overflow-y-auto border border-gray-200 rounded-lg p-4 mb-4 bg-white">
              {generatedContent ? (
                <div 
                  className="prose max-w-none"
                  dangerouslySetInnerHTML={{ __html: generatedContent }}
                />
              ) : (
                <div className="text-gray-400 text-center h-full flex items-center justify-center">
                  <p>
                    {isGenerating ? 
                      'Генерация контента...' : 
                      'Здесь появится сгенерированный контент'}
                  </p>
                </div>
              )}
            </div>
            
            <div className="flex gap-3">
              <button
                disabled={!generatedContent}
                onClick={() => onApplyText(generatedContent)}
                className={`flex-1 py-2 rounded-lg flex items-center justify-center ${
                  !generatedContent 
                    ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
                    : 'bg-orange-500 text-white hover:bg-orange-600'
                }`}
              >
                <FaCheck className="mr-2" /> Применить (заменить)
              </button>
              <button
                disabled={!generatedContent}
                onClick={() => onAppendText(generatedContent)}
                className={`flex-1 py-2 rounded-lg flex items-center justify-center ${
                  !generatedContent 
                    ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
                    : 'bg-gray-800 text-white hover:bg-gray-700'
                }`}
              >
                <FaPlus className="mr-2" /> Добавить к тексту
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

// После компонента AIWritingAssistant добавим компонент MistralAIAssistant
// Компонент модального окна ИИ-помощник (Mistral)
const MistralAIAssistant = ({ 
  isOpen, 
  onClose, 
  onApplyText,
  onAppendText,
  currentContent = ''
}: { 
  isOpen: boolean; 
  onClose: () => void; 
  onApplyText: (text: string) => void;
  onAppendText: (text: string) => void;
  currentContent?: string;
}) => {
  const [prompt, setPrompt] = useState('');
  const [generatedContent, setGeneratedContent] = useState('');
  const [isGenerating, setIsGenerating] = useState(false);
  const [error, setError] = useState('');
  
  // Режим работы: generate (статья), improve (улучшение), ideas (идеи), image (изображение)
  const [mode, setMode] = useState<'generate' | 'improve' | 'ideas' | 'image'>('generate');
  
  // Состояния для хранения контента в разных режимах
  const [generateContent, setGenerateContent] = useState('');
  const [improveContent, setImproveContent] = useState('');
  const [ideasContent, setIdeasContent] = useState('');
  const [imageContent, setImageContent] = useState('');
  const [improveOption, setImproveOption] = useState('grammar');
  
  // Параметры для генерации изображений
  const [pipelineId, setPipelineId] = useState('');
  const [imageStyle, setImageStyle] = useState('DEFAULT');
  const [imageAspectRatio, setImageAspectRatio] = useState('1:1');
  const [imageWidth, setImageWidth] = useState(512);
  const [imageHeight, setImageHeight] = useState(512);
  const [negativePrompt, setNegativePrompt] = useState('');
  const [showAdvancedImageSettings, setShowAdvancedImageSettings] = useState(false);
  const [checkingStatus, setCheckingStatus] = useState(false);
  
  // Доступные стили для генерации изображений
  const imageStyles = [
    { name: 'DEFAULT', title: 'Свой стиль' },
    { name: 'KANDINSKY', title: 'Кандинский' },
    { name: 'UHD', title: 'Детальное фото' },
    { name: 'ANIME', title: 'Аниме' }
  ];
  
  // Соотношения сторон для изображений
  const aspectRatios = [
    { name: '1:1', width: 512, height: 512 },
    { name: '3:2', width: 768, height: 512 },
    { name: '2:3', width: 512, height: 768 },
    { name: '16:9', width: 768, height: 432 },
    { name: '9:16', width: 432, height: 768 }
  ];
  
  // API ключ для Mistral
  const MISTRAL_API_KEY = 'OLyRmijddZw637e6jLCXR8H7DBOm6idj';
  
  // API ключи для FusionBrain
  const FUSION_BRAIN_API_KEY = '80810B8110B4948751EE149B79323C97';
  const FUSION_BRAIN_SECRET_KEY = '82CD04179C21806452EE34C351A882F7';
  const FUSION_BRAIN_URL = 'https://api-key.fusionbrain.ai/';
  
  // Варианты улучшения текста
  const improveOptions = [
    { id: 'grammar', title: 'Грамматика и стиль', prompt: 'Улучши грамматику, стиль и читаемость следующего текста. Исправь ошибки, улучши формулировки, но сохрани смысл и основное содержание.' },
    { id: 'expand', title: 'Расширить', prompt: 'Расширь следующий текст, добавив больше деталей, примеров и пояснений. Сделай текст более информативным и полным.' },
    { id: 'simplify', title: 'Упростить', prompt: 'Упрости следующий текст, сделай его более понятным и легким для чтения. Используй более простые слова и короткие предложения, сохраняя основную информацию.' },
    { id: 'rewrite', title: 'Переписать', prompt: 'Полностью перепиши следующий текст, сохраняя основной смысл и ключевые моменты, но используя другие слова и структуру.' },
    { id: 'custom', title: 'Свой вариант', prompt: '' }
  ];

  // Обновляем generatedContent при изменении режима работы
  useEffect(() => {
    console.log('Режим изменился на:', mode);
    console.log('Состояния содержимого:', {
      generate: generateContent ? 'есть содержимое' : 'пусто',
      improve: improveContent ? 'есть содержимое' : 'пусто',
      ideas: ideasContent ? 'есть содержимое' : 'пусто',
      image: imageContent ? 'есть содержимое' : 'пусто'
    });
    
    switch(mode) {
      case 'generate':
        setGeneratedContent(generateContent);
        break;
      case 'improve':
        setGeneratedContent(improveContent);
        break;
      case 'ideas':
        setGeneratedContent(ideasContent);
        break;
      case 'image':
        setGeneratedContent(imageContent);
        break;
    }
  }, [mode, generateContent, improveContent, ideasContent, imageContent]);

  // Функция для генерации контента с помощью Mistral API
  const generateWithMistralAI = async () => {
    if (isGenerating) return;
    
    // Очищаем предыдущие ошибки
    setError('');
    setIsGenerating(true);
    
    try {
      let finalPrompt = '';
      let responseField = '';
      
      // Формируем промпт в зависимости от режима
      if (mode === 'generate') {
        finalPrompt = `Напиши полноценную статью на тему: ${prompt}`;
        responseField = 'generate';
      } else if (mode === 'improve') {
        // Используем выбранный вариант улучшения или настраиваемый промпт
        const selectedOption = improveOptions.find(opt => opt.id === improveOption);
        if (selectedOption) {
          finalPrompt = selectedOption.id === 'custom' 
            ? `${prompt}\n\nТекст для улучшения:\n${currentContent}`
            : `${selectedOption.prompt}\n\nДополнительные указания: ${prompt}\n\nТекст для улучшения:\n${currentContent}`;
        }
        responseField = 'improve';
      } else if (mode === 'ideas') {
        finalPrompt = `Предложи 5-7 интересных идей для статей на тему: ${prompt}. Для каждой идеи укажи возможное название и краткое описание (2-3 предложения).`;
        responseField = 'ideas';
      } else if (mode === 'image') {
        // Для изображений используем FusionBrain API
        await generateImageWithFusionBrain();
        return;
      }
      
      console.log('Отправляем запрос в Mistral API с промптом:', finalPrompt);
      
      const response = await fetch('https://api.mistral.ai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${MISTRAL_API_KEY}`
        },
        body: JSON.stringify({
          model: 'mistral-large-latest',
          messages: [
            { role: 'system', content: 'Ты профессиональный копирайтер и эксперт по созданию контента. Отвечай только на русском языке. Твои ответы должны быть хорошо структурированными, с использованием HTML тегов для форматирования.' },
            { role: 'user', content: finalPrompt }
          ],
          temperature: 0.7,
          max_tokens: 4000
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(`Ошибка API Mistral: ${errorData.error?.message || response.statusText}`);
      }
      
      const data = await response.json();
      console.log('Получен ответ от Mistral API:', data);
      
      if (data.choices && data.choices.length > 0) {
        // Форматируем текст, добавляя HTML-теги для абзацев, если их нет
        let content = data.choices[0].message.content;
        
        // Если текст не содержит HTML-теги, добавляем базовое форматирование
        if (!content.includes('<')) {
          content = content
            .split('\n\n')
            .map((para: string) => para ? `<p>${para}</p>` : '')
            .join('');
        }
        
        // Сохраняем результат в соответствующее состояние
        if (responseField === 'generate') {
          setGenerateContent(content);
        } else if (responseField === 'improve') {
          setImproveContent(content);
        } else if (responseField === 'ideas') {
          setIdeasContent(content);
        }
      } else {
        throw new Error('Получен пустой ответ от API Mistral');
      }
    } catch (err) {
      console.error('Ошибка при генерации с помощью Mistral:', err);
      setError(`Ошибка: ${err instanceof Error ? err.message : 'Неизвестная ошибка'}`);
    } finally {
      setIsGenerating(false);
    }
  };
  
  // Функция для генерации изображения с помощью FusionBrain
  const generateImageWithFusionBrain = async () => {
    if (!pipelineId) {
      setError('Pipeline ID не найден. Пожалуйста, попробуйте перезагрузить страницу.');
      setIsGenerating(false);
      return;
    }
    
    try {
      const headers = {
        'X-Key': `Key ${FUSION_BRAIN_API_KEY}`,
        'X-Secret': `Secret ${FUSION_BRAIN_SECRET_KEY}`,
        'Content-Type': 'application/json'
      };
      
      // Создаем запрос на генерацию изображения
      const generationResponse = await fetch(`${FUSION_BRAIN_URL}key/api/v1/text2image/run`, {
        method: 'POST',
        headers,
        body: JSON.stringify({
          pipeline_id: pipelineId,
          params: {
            width: imageWidth,
            height: imageHeight,
            style: imageStyle,
            num_images: 1,
            prompt: prompt,
            negative_prompt: negativePrompt
          }
        })
      });
      
      if (!generationResponse.ok) {
        throw new Error(`Ошибка при запросе генерации: ${generationResponse.status}`);
      }
      
      const generationData = await generationResponse.json();
      const uuid = generationData.uuid;
      
      if (!uuid) {
        throw new Error('UUID не получен');
      }
      
      console.log('Запрос на генерацию отправлен, UUID:', uuid);
      
      // Проверяем статус генерации
      setCheckingStatus(true);
      let attempts = 0;
      const maxAttempts = 30;
      
      while (attempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, 2000)); // Ждем 2 секунды между запросами
        
        const statusResponse = await fetch(`${FUSION_BRAIN_URL}key/api/v1/text2image/status/${uuid}`, {
          method: 'GET',
          headers
        });
        
        if (!statusResponse.ok) {
          throw new Error(`Ошибка при проверке статуса: ${statusResponse.status}`);
        }
        
        const statusData = await statusResponse.json();
        console.log('Статус генерации:', statusData);
        
        if (statusData.status === 'DONE') {
          // Если изображение готово, получаем его
          if (statusData.images && statusData.images.length > 0) {
            const imageBase64 = statusData.images[0];
            const imageHTML = `<div class="text-center"><img src="data:image/jpeg;base64,${imageBase64}" alt="Сгенерированное изображение" class="max-w-full h-auto rounded-lg shadow-lg" /></div>`;
            setImageContent(imageHTML);
            break;
          } else {
            throw new Error('Изображение не найдено в ответе');
          }
        } else if (statusData.status === 'FAILED') {
          throw new Error(`Генерация не удалась: ${statusData.error || 'Неизвестная ошибка'}`);
        }
        
        attempts++;
      }
      
      if (attempts >= maxAttempts) {
        throw new Error('Превышено максимальное время ожидания генерации');
      }
    } catch (err) {
      console.error('Ошибка при генерации изображения:', err);
      setError(`Ошибка генерации изображения: ${err instanceof Error ? err.message : 'Неизвестная ошибка'}`);
    } finally {
      setIsGenerating(false);
      setCheckingStatus(false);
    }
  };

  // Если модальное окно закрыто, не рендерим ничего
  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4 overflow-auto">
      <div className="bg-white rounded-xl shadow-2xl w-full max-w-5xl max-h-[90vh] flex flex-col">
        <div className="flex items-center justify-between p-4 border-b bg-orange-500 text-white rounded-t-xl">
          <h3 className="text-xl font-semibold flex items-center">
            <FaRobot className="mr-2" /> 
            ИИ-помощник (Mistral)
          </h3>
          <button
            onClick={onClose}
            className="text-white hover:text-gray-200 transition-colors"
          >
            <FaTimes size={20} />
          </button>
        </div>
        
        <div className="flex flex-col md:flex-row h-full overflow-hidden">
          <div className="w-full md:w-1/3 p-4 border-r overflow-y-auto">
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Выберите режим работы
              </label>
              <div className="grid grid-cols-2 gap-2 mb-4">
                <button
                  onClick={() => setMode('generate')}
                  className={`py-2 px-3 text-sm rounded-lg flex items-center justify-center ${
                    mode === 'generate' 
                      ? 'bg-orange-500 text-white' 
                      : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                  }`}
                >
                  <FaPencilAlt className="mr-2 text-xs" /> Статья
                </button>
                <button
                  onClick={() => setMode('improve')}
                  className={`py-2 px-3 text-sm rounded-lg flex items-center justify-center ${
                    mode === 'improve' 
                      ? 'bg-orange-500 text-white' 
                      : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                  }`}
                >
                  <MdOutlineAutoFixHigh className="mr-2" /> Улучшить
                </button>
                <button
                  onClick={() => setMode('ideas')}
                  className={`py-2 px-3 text-sm rounded-lg flex items-center justify-center ${
                    mode === 'ideas' 
                      ? 'bg-orange-500 text-white' 
                      : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                  }`}
                >
                  <FaLightbulb className="mr-2 text-xs" /> Идеи
                </button>
                <button
                  onClick={() => setMode('image')}
                  className={`py-2 px-3 text-sm rounded-lg flex items-center justify-center ${
                    mode === 'image' 
                      ? 'bg-orange-500 text-white' 
                      : 'bg-gray-100 hover:bg-gray-200 text-gray-800'
                  }`}
                >
                  <FaImage className="mr-2 text-xs" /> Изображение
                </button>
              </div>
            </div>
            
            {mode === 'improve' && (
              <div className="mb-4">
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Способ улучшения
                </label>
                <select 
                  value={improveOption}
                  onChange={(e) => setImproveOption(e.target.value)}
                  className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                >
                  {improveOptions.map(option => (
                    <option key={option.id} value={option.id}>
                      {option.title}
                    </option>
                  ))}
                </select>
              </div>
            )}
            
            {mode === 'image' && (
              <div className="mb-4">
                <div className="flex justify-between items-center mb-2">
                  <label className="block text-sm font-medium text-gray-700">
                    Стиль изображения
                  </label>
                  <button
                    type="button"
                    onClick={() => setShowAdvancedImageSettings(!showAdvancedImageSettings)}
                    className="text-xs text-orange-500 hover:text-orange-700 flex items-center"
                  >
                    {showAdvancedImageSettings ? <FaChevronDown className="mr-1" /> : <FaChevronRight className="mr-1" />}
                    {showAdvancedImageSettings ? 'Скрыть настройки' : 'Дополнительные настройки'}
                  </button>
                </div>
                
                <select 
                  value={imageStyle}
                  onChange={(e) => setImageStyle(e.target.value)}
                  className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500 mb-3"
                >
                  {imageStyles.map((style) => (
                    <option key={style.name} value={style.name}>
                      {style.title}
                    </option>
                  ))}
                </select>
                
                <div className="mb-2">
                  <label className="block text-sm font-medium text-gray-700 mb-1">
                    Соотношение сторон
                  </label>
                  <div className="flex flex-wrap gap-2">
                    {aspectRatios.map((ratio) => (
                      <button
                        key={ratio.name}
                        type="button"
                        onClick={() => {
                          setImageAspectRatio(ratio.name);
                          setImageWidth(ratio.width);
                          setImageHeight(ratio.height);
                        }}
                        className={`px-3 py-1 text-xs rounded ${
                          imageAspectRatio === ratio.name
                            ? 'bg-orange-500 text-white'
                            : 'bg-gray-100 text-gray-800 hover:bg-gray-200'
                        }`}
                      >
                        {ratio.name}
                      </button>
                    ))}
                  </div>
                </div>
                
                {showAdvancedImageSettings && (
                  <div className="mb-3">
                    <label className="block text-sm font-medium text-gray-700 mb-2">
                      Негативный промпт
                    </label>
                    <textarea
                      value={negativePrompt}
                      onChange={(e) => setNegativePrompt(e.target.value)}
                      placeholder="Введите, что НЕ должно быть на изображении"
                      className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                      rows={2}
                    />
                    
                    <div className="flex gap-4 mt-3">
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                          Ширина (px)
                        </label>
                        <input
                          type="number"
                          value={imageWidth}
                          onChange={(e) => setImageWidth(parseInt(e.target.value))}
                          min={128}
                          max={1024}
                          step={64}
                          className="w-24 px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                        />
                      </div>
                      
                      <div>
                        <label className="block text-sm font-medium text-gray-700 mb-2">
                          Высота (px)
                        </label>
                        <input
                          type="number"
                          value={imageHeight}
                          onChange={(e) => setImageHeight(parseInt(e.target.value))}
                          min={128}
                          max={1024}
                          step={64}
                          className="w-24 px-3 py-2 rounded-lg border border-gray-300 focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                        />
                      </div>
                    </div>
                    
                    <div className="text-xs text-gray-500 mt-2">
                      Рекомендуется использовать значения, кратные 64. Максимальный размер: 1024×1024
                    </div>
                  </div>
                )}
              </div>
            )}
            
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                {mode === 'generate' ? 'Опишите желаемую статью' : 
                 mode === 'improve' ? 'Дополнительные указания (опционально)' : 
                 mode === 'ideas' ? 'Тема для идей' : 
                 'Опишите желаемое изображение'}
              </label>
              <textarea
                value={prompt}
                onChange={(e) => setPrompt(e.target.value)}
                placeholder={mode === 'generate' ? 'Например: Здоровые привычки для повышения продуктивности' : 
                             mode === 'improve' ? 'Например: Сделать текст более энергичным' : 
                             mode === 'ideas' ? 'Например: Тренды в веб-дизайне' : 
                             'Например: Закат над горами с озером на переднем плане, реалистичный стиль'}
                className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500"
                rows={5}
              />
            </div>
            
            {error && (
              <div className="mt-2 mb-4 p-3 bg-red-50 text-red-700 rounded-lg flex items-start">
                <FaExclamationTriangle className="mt-1 mr-2 flex-shrink-0" />
                <div>{error}</div>
              </div>
            )}
            
            <div className="mt-auto">
              <button
                onClick={generateWithMistralAI}
                disabled={isGenerating || (mode !== 'improve' && !prompt.trim()) || (mode === 'improve' && !currentContent && !prompt.trim())}
                className={`w-full py-2 rounded-lg flex items-center justify-center 
                  ${isGenerating || (mode !== 'improve' && !prompt.trim()) || (mode === 'improve' && !currentContent && !prompt.trim())
                    ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                    : 'bg-orange-500 text-white hover:bg-orange-600'
                  }`}
              >
                {isGenerating ? (
                  <>
                    <FaSpinner className="animate-spin mr-2" />
                    {checkingStatus ? 'Ожидание...' : 'Генерация...'}
                  </>
                ) : (
                  <>
                    {mode === 'generate' ? <FaPencilAlt className="mr-2" /> : 
                    mode === 'improve' ? <MdOutlineAutoFixHigh className="mr-2" /> : 
                    mode === 'ideas' ? <FaLightbulb className="mr-2" /> : 
                    <FaImage className="mr-2" />}
                    {mode === 'generate' ? 'Написать статью' : 
                    mode === 'improve' ? 'Улучшить текст' : 
                    mode === 'ideas' ? 'Предложить идеи' : 
                    'Создать изображение'}
                  </>
                )}
              </button>
            </div>
          </div>
          
          <div className="w-full md:w-2/3 p-4 flex flex-col h-full overflow-hidden">
            <h3 className="text-lg font-medium text-gray-800 mb-2">Результат</h3>
            
            <div className="flex-grow overflow-y-auto border border-gray-200 rounded-lg p-4 mb-4 bg-white">
              {generatedContent ? (
                <div 
                  className="prose max-w-none"
                  dangerouslySetInnerHTML={{ __html: generatedContent }}
                />
              ) : (
                <div className="text-gray-400 text-center h-full flex items-center justify-center">
                  <p>
                    {isGenerating ? 
                      'Генерация контента...' : 
                      'Здесь появится сгенерированный контент'}
                  </p>
                </div>
              )}
            </div>
            
            <div className="flex gap-3">
              <button
                disabled={!generatedContent}
                onClick={() => onApplyText(generatedContent)}
                className={`flex-1 py-2 rounded-lg flex items-center justify-center ${
                  !generatedContent 
                    ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
                    : 'bg-orange-500 text-white hover:bg-orange-600'
                }`}
              >
                <FaCheck className="mr-2" /> Применить (заменить)
              </button>
              <button
                disabled={!generatedContent}
                onClick={() => onAppendText(generatedContent)}
                className={`flex-1 py-2 rounded-lg flex items-center justify-center ${
                  !generatedContent 
                    ? 'bg-gray-300 text-gray-500 cursor-not-allowed' 
                    : 'bg-gray-800 text-white hover:bg-gray-700'
                }`}
              >
                <FaPlus className="mr-2" /> Добавить к тексту
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

// Основной компонент страницы добавления статьи
export default function AddArticlePage() {
  const { user, isLoading } = useAuth();
  const router = useRouter();
  const editorRef = useRef<RichTextEditorRef>(null);
  
  // Состояния страницы
  const [formData, setFormData] = useState<FormData>({
    title: '',
    excerpt: '',
    content: '',
    category: 'inspiration',
    image: null,
    imagePreview: '',
    status: 'published', // Меняем статус по умолчанию на 'published'
    specialistId: '',
    customCategory: ''
  });
  
  // Максимальная длина краткого описания
  const MAX_EXCERPT_LENGTH = 200;
  
  const [categories, setCategories] = useState<string[]>([]);
  const [specialists, setSpecialists] = useState<Specialist[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState('');
  const [loadingCategories, setLoadingCategories] = useState(true);
  const [loadingSpecialists, setLoadingSpecialists] = useState(true);
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isBannerGeneratorOpen, setIsBannerGeneratorOpen] = useState(false);
  const [isAIAssistantOpen, setIsAIAssistantOpen] = useState(false);
  const [isMistralAIAssistantOpen, setIsMistralAIAssistantOpen] = useState(false);
  
  // Загрузка категорий и специалистов при монтировании компонента
  useEffect(() => {
    const fetchServices = async () => {
      try {
        const response = await fetch('/api/services');
        if (response.ok) {
          const data = await response.json();
          // Извлекаем категории из услуг
          const serviceCategories = data.map((service: Service) => service.name);
          // Добавляем стандартные категории
          setCategories(['inspiration', ...serviceCategories]);
        }
      } catch (error) {
        console.error('Ошибка при загрузке услуг:', error);
      } finally {
        setLoadingCategories(false);
      }
    };
    
    const fetchSpecialists = async () => {
      try {
        const response = await fetch('/api/specialists');
        if (response.ok) {
          const data = await response.json();
          setSpecialists(data);
        }
      } catch (error) {
        console.error('Ошибка при загрузке специалистов:', error);
      } finally {
        setLoadingSpecialists(false);
      }
    };
    
    fetchServices();
    fetchSpecialists();
  }, []);
  
  // Защита маршрута
  useEffect(() => {
    if (!isLoading && (!user || user.role !== 'admin')) {
      router.push('/login');
    }
  }, [user, isLoading, router]);
  
  // Обработчик изменения полей формы
  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    
    // Для краткого описания ограничиваем длину
    if (name === 'excerpt' && value.length > MAX_EXCERPT_LENGTH) {
      return; // Не обновляем состояние, если превышена максимальная длина
    }
    
    setFormData(prev => ({ ...prev, [name]: value }));
    // Очищаем ошибку при изменении поля
    if (errors[name]) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors[name];
        return newErrors;
      });
    }
  };
  
  // Обработчик изменения контента статьи (редактор)
  const handleContentChange = (value: string) => {
    setFormData(prev => ({ ...prev, content: value }));
    if (errors.content) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors.content;
        return newErrors;
      });
    }
  };
  
  // Обработчик загрузки изображения
  const handleImageChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files[0]) {
      const file = e.target.files[0];
      const reader = new FileReader();
      
      reader.onloadend = () => {
        setFormData(prev => ({
          ...prev,
          image: file,
          imagePreview: reader.result as string
        }));
      };
      
      reader.readAsDataURL(file);
      
      // Очищаем ошибку при загрузке изображения
      if (errors.image) {
        setErrors(prev => {
          const newErrors = { ...prev };
          delete newErrors.image;
          return newErrors;
        });
      }
    }
  };
  
  // Обработчик кнопки для выбора изображения
  const triggerFileInput = () => {
    const fileInput = document.getElementById('imageInput');
    if (fileInput) {
      fileInput.click();
    }
  };
  
  // Обработчик для вставки изображения в редактор
  const handleInsertImage = (url: string) => {
    if (editorRef.current) {
      editorRef.current.insertImage(url);
    }
  };
  
  // Функции форматирования текста (не используются, поскольку панель инструментов удалена)
  const handleFormatText = (format: string) => {
    if (editorRef.current) {
      editorRef.current.format(format);
    }
  };
  
  // Валидация формы перед отправкой
  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};
    
    if (!formData.title.trim()) {
      newErrors.title = 'Пожалуйста, введите заголовок';
    }
    
    if (!formData.excerpt.trim()) {
      newErrors.excerpt = 'Пожалуйста, введите короткое описание';
    }
    
    if (!formData.content.trim()) {
      newErrors.content = 'Пожалуйста, введите содержание статьи';
    }
    
    if (!formData.image && !formData.imagePreview) {
      newErrors.image = 'Пожалуйста, загрузите изображение обложки';
    }
    
    if (formData.category === 'customCategory' && !formData.customCategory) {
      newErrors.customCategory = 'Пожалуйста, введите название категории';
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  // Отправка формы
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Валидация формы
    if (!validateForm()) {
      return;
    }
    
    setIsSubmitting(true);
    setSubmitError('');
    
    try {
      // Создаем FormData для отправки файла
      const articleData = new FormData();
      articleData.append('title', formData.title);
      articleData.append('excerpt', formData.excerpt);
      articleData.append('content', formData.content);
      
      // Добавляем категорию, проверяя что значение определено
      const category = formData.category === 'custom' 
        ? formData.customCategory || '' 
        : formData.category || '';
      articleData.append('category', category);
      
      // Добавляем ID специалиста, если выбран
      if (formData.specialistId) {
        articleData.append('specialistId', formData.specialistId);
      }
      
      // Добавляем статус публикации
      articleData.append('status', formData.status);
      
      // Добавляем изображение, если оно выбрано
      if (formData.image) {
        articleData.append('image', formData.image);
      }
      
      // Отправляем данные на сервер
      const response = await fetch('/api/articles', {
        method: 'POST',
        body: articleData
      });
      
      if (response.ok) {
        const data = await response.json();
        // Перенаправляем на страницу со списком статей
        router.push('/admin/articles');
      } else {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Произошла ошибка при сохранении статьи');
      }
    } catch (error) {
      console.error('Ошибка при сохранении статьи:', error);
      toast.error('Ошибка при сохранении статьи. Пожалуйста, попробуйте снова.');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  // Обработчик применения сгенерированного баннера
  const handleApplyGeneratedBanner = (imageUrl: string) => {
    setFormData(prev => ({
      ...prev,
      imagePreview: imageUrl
    }));
    
    // Очищаем ошибку, если была
    if (errors.image) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors.image;
        return newErrors;
      });
    }
  };
  
  // Обработчик применения сгенерированного текста
  const handleApplyGeneratedText = (text: string) => {
    // Заменяем содержимое редактора
    setFormData(prev => ({
      ...prev,
      content: text
    }));
    
    // Очищаем ошибку, если была
    if (errors.content) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors.content;
        return newErrors;
      });
    }
  };
  
  // Обработчик добавления сгенерированного текста
  const handleAppendGeneratedText = (text: string) => {
    // Добавляем к содержимому редактора
    setFormData(prev => ({
      ...prev,
      content: prev.content + text
    }));
    
    // Очищаем ошибку, если была
    if (errors.content) {
      setErrors(prev => {
        const newErrors = { ...prev };
        delete newErrors.content;
        return newErrors;
      });
    }
  };
  
  // Если загрузка данных о пользователе ещё продолжается, показываем загрузчик
  if (isLoading) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="w-10 h-10 border-4 border-gray-300 border-t-[#48a9a6] rounded-full animate-spin"></div>
      </div>
    );
  }
  
  // Если пользователь не авторизован или не является администратором, не показываем содержимое
  if (!user || user.role !== 'admin') {
    return null;
  }
  
  return (
    <div className="container max-w-6xl mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-3xl font-bold text-gray-800">Добавление статьи</h1>
        <Link 
          href="/admin/articles" 
          className="px-4 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 transition-colors"
        >
          Вернуться к списку
        </Link>
      </div>
      
      <form onSubmit={handleSubmit} className="space-y-6">
        {/* Блок с изображением обложки */}
        <div className="bg-white rounded-2xl shadow-md p-6">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-xl font-semibold text-gray-800">Обложка статьи</h2>
            <button
              type="button"
              onClick={() => setIsBannerGeneratorOpen(true)}
              className="px-4 py-2 bg-[#48a9a6] text-white rounded-lg hover:bg-[#3d8e8c] transition-colors flex items-center gap-2"
            >
              <FaMagic /> Сгенерировать обложку
            </button>
          </div>
          
          <div className="flex flex-col md:flex-row gap-6">
            <div className="w-full md:w-1/3">
              <div 
                className="relative w-full aspect-video bg-gray-100 rounded-lg overflow-hidden cursor-pointer mb-3"
                onClick={triggerFileInput}
              >
                {formData.imagePreview ? (
                  <Image 
                    src={formData.imagePreview} 
                    alt="Предпросмотр" 
                    className="object-cover"
                    fill
                  />
                ) : (
                  <div className="flex items-center justify-center h-full">
                    <div className="text-center">
                      <FaImage size={40} className="mx-auto text-gray-400" />
                      <p className="mt-2 text-sm text-gray-500">Нажмите, чтобы загрузить</p>
                    </div>
                  </div>
                )}
              </div>
              
              <input 
                type="file" 
                id="imageInput" 
                accept="image/*" 
                onChange={handleImageChange} 
                className="hidden" 
              />
              
              <div className="flex justify-between">
                <button
                  type="button"
                  onClick={triggerFileInput}
                  className="px-3 py-1.5 bg-gray-100 text-gray-700 rounded hover:bg-gray-200 transition-colors text-sm flex items-center gap-2"
                >
                  <FaUpload size={12} /> Загрузить
                </button>
                
                {formData.imagePreview && (
                  <button
                    type="button"
                    onClick={() => setFormData(prev => ({ ...prev, image: null, imagePreview: '' }))}
                    className="px-3 py-1.5 bg-red-50 text-red-600 rounded hover:bg-red-100 transition-colors text-sm flex items-center gap-2"
                  >
                    <FaTimes size={12} /> Удалить
                  </button>
                )}
              </div>
              
              {errors.image && (
                <div className="mt-2 text-red-500 text-sm">{errors.image}</div>
              )}
            </div>
            
            <div className="w-full md:w-2/3 space-y-4">
              {/* Заголовок статьи */}
              <div>
                <label htmlFor="title" className="block text-sm font-medium text-gray-700 mb-1">
                  Заголовок статьи*
                </label>
                <input
                  type="text"
                  id="title"
                  name="title"
                  value={formData.title}
                  onChange={handleChange}
                  className={`w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-[#48a9a6] focus:border-transparent ${
                    errors.title ? 'border-red-500' : 'border-gray-300'
                  }`}
                  placeholder="Введите заголовок статьи"
                />
                {errors.title && (
                  <div className="mt-1 text-red-500 text-sm">{errors.title}</div>
                )}
              </div>
              
              {/* Короткое описание */}
              <div>
                <div className="flex justify-between mb-1">
                  <label htmlFor="excerpt" className="block text-sm font-medium text-gray-700">
                    Краткое описание*
                  </label>
                  <span className="text-xs text-gray-500">
                    {formData.excerpt.length}/{MAX_EXCERPT_LENGTH} символов
                  </span>
                </div>
                <textarea
                  id="excerpt"
                  name="excerpt"
                  rows={3}
                  value={formData.excerpt}
                  onChange={handleChange}
                  className={`w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-[#48a9a6] focus:border-transparent ${
                    errors.excerpt ? 'border-red-500' : 'border-gray-300'
                  }`}
                  placeholder="Краткое описание статьи (будет отображаться в списке)"
                  maxLength={MAX_EXCERPT_LENGTH}
                />
                {errors.excerpt && (
                  <div className="mt-1 text-red-500 text-sm">{errors.excerpt}</div>
                )}
              </div>
              
              {/* Категория и специалист */}
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                  <label htmlFor="category" className="block text-sm font-medium text-gray-700 mb-1">
                    Категория*
                  </label>
                  {loadingCategories ? (
                    <SkeletonLoader />
                  ) : (
                    <div>
                      <select
                        id="category"
                        name="category"
                        value={formData.category}
                        onChange={handleChange}
                        className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#48a9a6] focus:border-transparent"
                      >
                        {categories.map(category => (
                          <option key={category} value={category}>
                            {category === 'inspiration' ? 'Вдохновение' : category}
                          </option>
                        ))}
                        <option value="customCategory">Другая категория</option>
                      </select>
                      
                      {formData.category === 'customCategory' && (
                        <div className="mt-2">
                          <input
                            type="text"
                            name="customCategory"
                            value={formData.customCategory}
                            onChange={handleChange}
                            className={`w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-[#48a9a6] focus:border-transparent ${
                              errors.customCategory ? 'border-red-500' : 'border-gray-300'
                            }`}
                            placeholder="Введите название категории"
                          />
                          {errors.customCategory && (
                            <div className="mt-1 text-red-500 text-sm">{errors.customCategory}</div>
                          )}
                        </div>
                      )}
                    </div>
                  )}
                </div>
                
                <div>
                  <label htmlFor="specialistId" className="block text-sm font-medium text-gray-700 mb-1">
                    Автор (специалист)
                  </label>
                  {loadingSpecialists ? (
                    <SkeletonLoader />
                  ) : (
                    <select
                      id="specialistId"
                      name="specialistId"
                      value={formData.specialistId}
                      onChange={handleChange}
                      className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-[#48a9a6] focus:border-transparent"
                    >
                      <option value="">Не выбран</option>
                      {specialists.map(specialist => (
                        <option key={specialist.id} value={specialist.id}>
                          {specialist.firstName} {specialist.lastName}
                        </option>
                      ))}
                    </select>
                  )}
                </div>
              </div>
              
              {/* Статус публикации */}
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">
                  Статус публикации
                </label>
                <div className="flex space-x-4">
                  {/* Изменяем порядок опций: сначала "Опубликована", затем "Черновик" */}
                  <label className="flex items-center space-x-2 cursor-pointer">
                    <input
                      type="radio"
                      name="status"
                      value="published"
                      checked={formData.status === 'published'}
                      onChange={handleChange}
                      className="form-radio text-[#48a9a6] focus:ring-[#48a9a6]"
                    />
                    <span>Опубликована</span>
                  </label>
                  <label className="flex items-center space-x-2 cursor-pointer">
                    <input
                      type="radio"
                      name="status"
                      value="draft"
                      checked={formData.status === 'draft'}
                      onChange={handleChange}
                      className="form-radio text-[#48a9a6] focus:ring-[#48a9a6]"
                    />
                    <span>Черновик</span>
                  </label>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        {/* Редактор содержимого */}
        <div className="bg-white rounded-2xl shadow-md p-6">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-xl font-semibold text-gray-800">Содержание статьи</h2>
            <div className="flex gap-2">
              <button
                type="button"
                onClick={() => setIsMistralAIAssistantOpen(true)}
                className="px-4 py-2 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition-colors flex items-center gap-2"
              >
                <FaRobot /> ИИ-помощник
              </button>
              <button
                type="button"
                onClick={() => setIsAIAssistantOpen(true)}
                className="px-4 py-2 bg-[#48a9a6] text-white rounded-lg hover:bg-[#3d8e8c] transition-colors flex items-center gap-2"
              >
                <FaRobot /> ИИ-доп.(VPN)
              </button>
            </div>
          </div>
          
          {/* Удаляем панель инструментов, оставляем только редактор */}
          <div className="border border-gray-300 rounded-lg overflow-hidden">
            <RichTextEditor
              ref={editorRef}
              value={formData.content}
              onChange={handleContentChange}
              onInsertImage={handleInsertImage}
              className="min-h-[400px]"
            />
          </div>
          
          {errors.content && (
            <div className="mt-2 text-red-500 text-sm">{errors.content}</div>
          )}
        </div>
        
        {/* Кнопка сохранения */}
        <div className="flex justify-end">
          <button
            type="submit"
            disabled={isSubmitting}
            className={`px-6 py-3 bg-[#48a9a6] text-white rounded-lg hover:bg-[#3d8e8c] transition-colors flex items-center gap-2 ${
              isSubmitting ? 'opacity-70 cursor-not-allowed' : ''
            }`}
          >
            {isSubmitting ? (
              <>
                <FaSpinner className="animate-spin" />
                Сохранение...
              </>
            ) : (
              <>
                <FaSave />
                Сохранить статью
              </>
            )}
          </button>
        </div>
      </form>
      
      {/* Модальные окна */}
      <BannerGenerator 
        isOpen={isBannerGeneratorOpen} 
        onClose={() => setIsBannerGeneratorOpen(false)} 
        onApplyImage={handleApplyGeneratedBanner} 
      />
      
      <AIWritingAssistant 
        isOpen={isAIAssistantOpen} 
        onClose={() => setIsAIAssistantOpen(false)} 
        onApplyText={handleApplyGeneratedText}
        onAppendText={handleAppendGeneratedText}
        currentContent={formData.content}
      />
      
      <MistralAIAssistant 
        isOpen={isMistralAIAssistantOpen} 
        onClose={() => setIsMistralAIAssistantOpen(false)} 
        onApplyText={handleApplyGeneratedText}
        onAppendText={handleAppendGeneratedText}
        currentContent={formData.content}
      />
    </div>
  );
}